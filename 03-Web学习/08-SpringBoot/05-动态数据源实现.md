[toc]

# 动态数据源

## 1 需求场景

web项目中需要配置多个数据源，在某种情况下使用特定的数据源。

举例

1. 项目中需要进行读写分离，读是一个数据库来，写是另一个数据库
2. 特殊场景下，传入什么数据源就要用这个数据源进行查询，也就是数据源不确定。

<img src="picture/image-20210318131857197.png" alt="image-20210318131857197" style="zoom:80%;" />

## 2 多数据源简单实现

在一个普通Spring + Mybatis项目中，如果使用了多数据源，可以通过在dao层注入不同的SqlSessionTemplate来实现与不同数据库交互的目的。单个SqlSessionTemplate注入容器的过程如下：

```xml
    <!-- 配置数据源 -->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!-- 注册sqlSessionFactory -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="configLocation" value="classpath:config/mybatis-config.xml"/>
        <property name="typeAliasesPackage" value="com.wch.base.domain"/>
        <property name="mapperLocations" value="classpath:mapper/*.xml"/>
    </bean>

    <!-- 配置dao接口扫描，配置sqlSessionTemplate -->
    <context:component-scan base-package="com.wch.base.mapper"/>
    <bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
        <constructor-arg ref="sqlSessionFactory"/>
    </bean>
```

缺点：

- 如果项目需要连接多个数据源，从DataSource、SqlSessionFactory、SqlSessionTemplate都需要配置多次，难于维护和管理。
- 而且这种情况只适用于数据源确定的情况（也就是我们一开始就知道要访问哪些数据源）。

## 3 AbstractRoutingDataSource

AbstractRoutingDataSource是spring-jdbc包提供的一个AbstractDataSource的抽象类，它实现了DataSource接口用于获取数据库连接的方法。

```java
    @Override
    public Connection getConnection() throws SQLException {
        return determineTargetDataSource().getConnection();
    }

    @Override
    public Connection getConnection(String username, String password) throws SQLException {
        return determineTargetDataSource().getConnection(username, password);
    }

    protected DataSource determineTargetDataSource() {
        Assert.notNull(this.resolvedDataSources, "DataSource router not initialized");
        // 获取指定数据源关键字
        Object lookupKey = determineCurrentLookupKey();
        DataSource dataSource = this.resolvedDataSources.get(lookupKey);
        if (dataSource == null && (this.lenientFallback || lookupKey == null)) {
            dataSource = this.resolvedDefaultDataSource;
        }
        if (dataSource == null) {
            throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]");
        }
        return dataSource;
    }

    public void setTargetDataSources(Map<Object, Object> targetDataSources) {
        this.targetDataSources = targetDataSources;
    }
```

AbstractRoutingDataSource的内部维护了一个名为targetDataSources的Map，并提供的setter方法用于设置数据源关键字与数据源的关系，实现类被要求实现其determineCurrentLookupKey()方法，由此方法的返回值决定具体从哪个数据源中获取连接。

## 4 动态数据源代码实现

### 4.1 DataSourceContextHolder - 线程本地





4.2 











## ps-相关引用

[AbstractRoutingDataSource -- Spring提供的轻量级数据源切换方式](https://www.jianshu.com/p/b158476dd33c)