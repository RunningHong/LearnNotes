[TOC]

# TCP

TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

## 1 TCP的特性

- TCP 提供一种**面向连接的、可靠的**字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验、确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

## 2 TCP可靠性的保证

- **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
- **对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
- **丢弃重复数据**：对于重复数据，能够丢弃重复数据；
- **应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- **超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

## 3 TCP流量控制

可以用一句话概括，流量控制是为了`控制发送方发送速率，保证接收方来得及接收。`怎么实现的呢？

`接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。`将窗口字段设置为 0，则发送方不能发送数据。`如果接收方有足够大的接收缓存，就不会发生流量控制；`

### 3.1 如何实现流量控制 ?

TCP中由`滑动窗口协议（连续ARQ协议）实现`。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。`主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。`

### 3.2 流量控制引发的死锁？

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。

### 3.3 怎么避免死锁的发生？

为了避免流量控制引发的死锁，`TCP使用了持续计时器`。每当发送者`收到一个0窗口的应答后就启动该计时器`。**时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。

## 4 TCP拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![在这里插入图片描述](https://img-blog.csdn.net/20180921113337166?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0dV96a2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

### 4.1 慢开始与拥塞避免

先了解一波名词

- cwnd ，拥塞窗口
- ssthresh ，处理拥塞时参照的一个参数
- `虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。`

![在这里插入图片描述](https://img-blog.csdn.net/20180921114720493?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0dV96a2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

### 4.2 快重传和快恢复

![在这里插入图片描述](https://img-blog.csdn.net/20180921115203181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0dV96a2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。
- 在发送方，`如果收到三个重复确认，那么可以知道下一个报文段丢失`，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。
- 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。
- `慢开始`和`快恢复`的**快慢**指的是`cwnd`的**设定值**，而不是`cwnd` 的**增长速率**。**慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。