[TOC]

# Spring -IOC

## 1 Spring IOC理解（反射实现）

控制反转/依赖注入

IOC是遵循了软件设计理念的**依赖倒转原则**以及**接口隔离原则**，面向对象的设计就是为了而实现软件的更好的复用性和扩展性。

## 2 接口隔离原则（面向接口编程）

如果A要使用B的实例那么不要直接在A中对B进行初始化，而是在A中定义一个接口(Interface)，让B去实现这个接口(Interface)。

在这我们可以举一个关于电脑主机的例子：在电脑主机（A类）里有CPU、内存条（B的实例），直接实例化其实就相当于把所有的东西一体化（把所有东西都整合在一起，高耦合度，要换其中的一样东西需要把整体全部换掉），如果我们采用接口隔离原则即把各个东西分开，之后在主板（A类）上有各种各样的卡槽（A中接口Interface），内存条、CPU（B的实例）按照它们各自的卡槽标准（需要实现接口）生产，这时如果我们觉得内存不够了，就不用把这个主板全部更换掉而是直接更换内存条。

## 3 依赖、倒置

**依赖**：从程序角度看比如A要调用B的方法，那么A就依赖于B；

**倒置**：在一般程序中如果**不倒置**则需要在A中主动获取B的实例：B b = new B()；这就是获取B实例的方法。**倒置**的的意思是A不再需要主动去获取B而是由其他人自动把B送上门。

在这里我们可以举一个在商店买水的例子来描述依赖倒置：

某一天我口渴了，想要喝水，这时我可以到商店去买水，告诉他们我需要一瓶水，然后他们就直接给我一瓶水（我主动的去获取水，我依赖于商店），这个本来没有太大的问题，但是如果商店离我们很远，那么我必需知道，该如何去商店，商店里是否有我需要的水等等复杂的情况。

解决这个问题最简单的方法就是让商店直接把水送给我，这样对于我来说就不用关心太多的杂事，这样一来我就只用做两件事情，**第一在商店注册**，**第二告诉商店我需要什么**（面向接口编程的体现，更改配置让商店提供不同的商品）。

上面的做法其实就很像Spring的做法：Spring就是商店，我就是对象A，水就是B的对象，我们要怎样才能使用Spring的这个特性呢？**第一在Spring中声明一个类A**，**第二告诉Spring，A需要B**。

假设A是UserAction，B是UserService,则配置为（当然也可以用注解的方式）：

```xml
<bean id="userService" class="org.service.UserService"></bean>
<bean id="userAction" class="org.action.UserAction">
	<property name="userService" ref="userService"></property>
</bean>
```

## 4 IOC容器的初始化过程

 资源定位，即定义bean的xml-------》载入--------》IOC容器注册，注册beanDefinition

 IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。

## 5 三种注入方式

构造器、接口、set注入，我们常用的是set注入。

bean是如何创建---  工厂模式

数据是如何注入（实现原理）：**反射**

## 6 依赖注入的使用

在程序运行的时候，根据情况给对应的变量设置值。

- @Repository 只能标注在 DAO 类。

- @Component 是一个泛化的概念，仅仅表示一个组件 (Bean) ，可以作用在任何层次。
- @Service 通常作用在业务层，但是目前该功能与 @Component 相同。
- @Controller 通常作用在控制层，但是目前该功能与 @Component 相同。

- @Autowired：默认是以byName的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byType的方式去查找，如果查找到多个，用@Qualifier注解限定具体使用哪个。

  ```java
  @Autowired
  @Qualifier("userDaoJdbc")
  private IUserDao userDao;
  ```
