# 1 Hibernate缓存机制

## 1.1 why(为什么用Hibernate缓存)

首先为什么要用缓存，我们都知道Hibernate是一个持久层框架，我们利用Hibernate来访问数据库，每次访问数据都会花费时间，这时为了降低访问的次数，我们就利用了缓存来提高应用程序的运行性能。

缓存中的是数据是对数据源中的数据的一个复制，应用程序访问数据时先读缓存，如果缓存中没有得到想要的的数据，再从数据库读取数据并把数据存入缓存中（缓存很像一个大管家，当我们想要见一个人的时候（数据库的数据）就会先去问大管家这个人的房间号，如果大管家知道就直接告诉我们房号，如果大管家不知道他就会去查找这个人的房间号是多少，之后自己记下来给后人参考，最后告诉我们，这就大大减少了我们去找人的时间）。

## 1.2 what(Hibernate缓存原理)

HIbernate缓存分为两类，分别是**一级缓存**和**二级缓存**。

- Hibernate**一级缓存**又称为**Session缓存**，事务级缓存 。
  Session是Hibernate内置的，Session的缓存是事务范围的缓存，一级缓存中，持久化类的每个实例都有唯一的OID。

- Hibernate**二级缓存**又称为**SessionFactory缓存**，应用级缓存。
  由于SessionFactory对象的生命周期就相当于整应用程序的生命周期,因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略被缓存的数据提供了事务隔离级别。

  HIbernate的二级缓存是可选的，是一个可配置的插件，默认不会使用SessionFactory。

  **什么样的数据适合存放到二级缓存中**？

  1. 很少被修改的数据。
  2. 不是很重要的数据，允许出现偶尔并发的数据。
  3. 不会被并发访问的数据。

  **不适合存放到二级缓存的数据**

  1. 经常被修改的数据。
  2. 不允许发生并发访问的数据（财务数据）
  3. 与其他应用共享的数据。

## 1.3 how(怎样使用)

- 一级缓存的应用：
  save（）方法，当session对象调用save()方法后，该对象会被放到Session的缓存中。当调用get()或load()方法后会在session中寻找数据。
  flush()方法刷新以及缓存的内容，使之与数据库数据同步。
  clear()方法将以及缓存中的所有持久化对象清除，释放其占用的内存资源。

  contains(Object obj) : 判断指定的对象是否存在于一级缓存中。
  evict(Object obj)：从缓存中清除参数指定的持久化对象。

- 二级缓存的管理
  evict(Class arg0, Serializable arg1)将某个类的指定ID的持久化对象从二级缓存中清除,释放对象所占用的资源。

  ```
  sessionFactory.evict(Customer.class, new Integer(1));  
  ```

  evict(Class arg0)  将指定类的所有持久化对象从二级缓存中清除,释放其占用的内存资源。

  ```
  sessionFactory.evict(Customer.class);  
  ```

  evictCollection(String arg0)  将指定类的所有持久化对象的指定集合从二级缓存中清除,释放其占用的内存资源。

  ```
  sessionFactory.evictCollection("Customer.orders");  
  ```



**常用的缓存插件（二级缓存）**

二级缓存是一个插件，下面是几种常用的缓存插件：

- EhCache:可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，对Hibernate的查询缓存提供了支持。
- OSCache:可作为进程范围的缓存，存放数据的物理截止可以是内存或硬盘，提供了丰富的缓存数据过期策略，对Hibernate的查询缓存提供了支持。
- SwarmCache：可作为群集范围内的缓存，但不支持Hibernate的查询缓存。
- JBossCache：可作为群集范围内的缓存，支持是事务型并发访问策略，对Hibernate的查询缓存提供了支持。











