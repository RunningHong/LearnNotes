# 1 排序相关

![算法时间复杂度稳定性综合](https://github.com/RunningHong/LearnNotes/blob/master/picture/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%BB%BC%E5%90%88.png?raw=true)

**稳定性**：通俗地讲就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。

## 1.1 冒泡排序

### 1.1.1 传统冒泡

```java
    /**
     * 冒泡排序算法（从小到大）
     * 原理：依次比较两个相邻的数，如果第一个数比第二个数大则交换这连个数的位置
     * @param array
     * @return
     */
    public int[] bubbleSort(int[] array) {
        for(int i=array.length-1; i>=0; i--) {
            for(int j=0; j<i; j++) {
                if(array[j] > array[j+1]) {
                    int temp = array[j+1];
                    array[j+1] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }
```

![](https://github.com/CyC2018/CS-Notes/blob/master/pics/1a2f2998-d0da-41c8-8222-1fd95083a66b.png?raw=true)

冒泡排序是最简单的排序算法，时间复杂度为O(n<sup>2</sup>)；

算法思路：依次比较相邻的两个数，如果按照判断条件则进行相应的交换两个数字的操作。因为每次都是把一个数放到最前或最后，很像泡泡从水底冒出的样子，故命名为冒泡算法。

如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个元素相邻起来，最终也不会交换它俩的位置，所以相同元素经过排序后顺序并没有改变。所以冒泡排序是一种**稳定**排序算法。 

### 1.1.2 升级版（设置判断标志位）

```java
	/**
	 * 冒泡排序升级版（从小到大）
	 * 原理：通过一个标志判断如果发现一趟循环中没有交换的元素了就说明已经排好序了后面就不用再比较
	 * @return
	 */
	public int[] bubbuleSortUpgrade(int[] array) {
		
		boolean exitFlag = false; // 退出标志位
		for(int i=array.length-1; i>=0; i--) {
			exitFlag = true; // 循环之前把标志位置为退出
	        for(int j=0; j<i; j++) {
	            if(array[j] > array[j+1]) {
	                int temp = array[j+1];
	                array[j+1] = array[j];
	                array[j] = temp;
	                
	                exitFlag = false; // 如果一次循环中有交换的则把标志位置为false
	            }
	        }
	        
			if(exitFlag == true) { // 如果退出标志位exitFlag为true则说明，这次循环中数组已经有序了则直接退出循环
				break;
			}
	    }
		return array;
	}
```

## 1.2 选择排序

```java
    /**
     * 选择排序算法(从小到大)
     * 原理：每一次从待排序的序列中选择最小和初始位置的元素进行交换
     * @param array
     * @return
     */
    public int[] selectionSort(int[] array) {
        int minIndex = 0;
        int temp;
        for(int i=0; i<array.length; i++) {
            minIndex = i; // 初始设置最小的值下标为i
            for(int j=i+1; j<array.length; j++) {
                if(array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            // 每一次循环，找到最小的值的下标后，交换两个数的位置
            temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
        return array;
    }
```

![](https://raw.githubusercontent.com/CyC2018/CS-Notes/master/pics/37e79a32-95a9-4503-bdb1-159527e628b8.png)

时间复杂度为O(n<sup>2</sup>)；

算法**不稳定**; 举个例子：序列5 8 5 2 9， 我们知道第一趟选择第1个元素5会与2进行交换，那么原序列中两个5的相对先后顺序也就被破坏了。所以选择排序是一个**不稳定**的排序算法。          

## 1.3 插入排序

插入排序有可以分为**直接插入排序**和**希尔排序**。

### 1.3.1 直接插入排序

```java
	/**
	 * 插入排序(从小到大)
	 * 原理：每次循环找到最小元素的下标，记录这个元素的值，之后把从判断位的元素到最小值下标的元素全部后移一位，最后把记录的最小值赋值到判断位
	 * @param array
	 * @return
	 */
	public int[] insertSort(int[] array) {
		
		int minIndex;
		for(int i=0; i<array.length; i++) {
			minIndex = i; // 初始设置最小值的下标为i
			for(int j=i+1; j<array.length; j++) { // 循环找到最小值的下标
				if(array[j]<array[minIndex]) {
					minIndex = j;
				}
			}
			
			int minValue = array[minIndex]; // 最小值
			System.arraycopy(array, i, array, i+1, minIndex-i);  // 把从i到minIndex(共 minIndex-i)的下标的元素向后移1位
			array[i] = minValue;
		}
		return array;
	}
```

![img](https://github.com/RunningHong/LearnNotes/blob/master/picture/selectionSort.png?raw=true)

### 1.3.2 希尔排序

```java

```







	





















