# 1 事务

## 1.1 什么是事务

事务可以理解为一个 **独立的工作单元**, 在这个独立的工作单元中, 有**一组操作**，放在事务(独立工作单元)中的多个操作, **要么全部执行成功, 要么全部执行失败**。

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

![](https://github.com/CyC2018/CS-Notes/blob/master/pics/185b9c49-4c13-4241-a848-fbff85c03a64.png?raw=true)

------

## 1.2 ACID（事务四大特性）

### 1.2.1 原子性（Atomicity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

对于一个事务来说, 不能只成功执行其中的一部分操作, 这就是事务的原子性。

回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

### 1.2.2 一致性（Consistency）

数据库在事务执行前后保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

比如一个转账的例子:A初始200 ，B初始300，A给B转100。

```
转账前一致性状态是：A(200元)，B(300元)
转账100元成功后一致性状态：A（100元），B(400元)
如果转账失败，一致性状态应该回滚到转账前的状态:A(200元)，B(300元)
```

### 1.2.3 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

事务有四种隔离级别(从低到高: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)

即（未读提交、读提交、可重复读、序列化）

### 1.2.4 持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。

------

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

[![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png)](https://github.com/CyC2018/CS-Notes/blob/master/pics/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png)

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。

## 1.3 并发中可能出现的问题

### 1.3.1 丢失修改（Lost update）
如果**多个线程操作，基于同一个查询结构对表中的记录进行修改，那么后修改的记录将会覆盖前面修改的记录，前面的修改就丢失掉了，这就叫做更新丢失**。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

[![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png)](https://github.com/CyC2018/CS-Notes/blob/master/pics/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png)

### 1.3.2 读脏数据（Dirty Reads）

**A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。**

T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

[![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/dd782132-d830-4c55-9884-cfac0a541b8e.png)](https://github.com/CyC2018/CS-Notes/blob/master/pics/dd782132-d830-4c55-9884-cfac0a541b8e.png)

### 1.3.3 不可重复读（Non-repeatable Reads）

**如果在一个事务中多次读取同一个数据, 正好在两次读取之间, 另外一个事务确实已经完成了对该数据的修改并提交, 那问题就来了: 可能会出现多次读取结果不一致的现象。**

T2 读取**一个数据**，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

[![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/c8d18ca9-0b09-441a-9a0c-fb063630d708.png)](https://github.com/CyC2018/CS-Notes/blob/master/pics/c8d18ca9-0b09-441a-9a0c-fb063630d708.png)

### 1.3.4 幻影读

- 容易搞混**不可重复读** 和**幻读** ，都是说两次读取数据不一致。
- 但**不可重复读**主要是说多次读取**一条记录**, 发现该记录中某些列值被修改过。
- 而**幻读**主要是说多次读取**一个范围内的记录**(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多（一般来讲）, 记录的减少应该也算是幻读（猜测）)。
- 指两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中。 通俗的讲，一个线程中的事务读取到了另外一个事务insert的数据。

T1 读取某个**范围的数据**，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

[![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png)](https://github.com/CyC2018/CS-Notes/blob/master/pics/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png)

## 1.4 封锁粒度

MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁**。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

**总的来说：能少锁就少锁（减少系统开销）**

## 1.5 封锁类型

### 1.5.1 读写锁

- **排它锁**（Exclusive）,简写为X锁，又称为写锁。
- **共享锁**（Shared）， 简写为S锁，又称为读锁。

有以下两个规定：

1. 一个事务对数据对象A加了X锁，就可以对A读取和更新。加锁期间其它事务不能对A加任何锁。
2. 一个事务对数据对象A加了S锁，可以对A进行读取操作，当不能进行更新操作。加锁期间其它事务能对A加S锁当不能加X锁。

锁的兼容关系如下（即只有S锁可以加S锁，其他情况都不可以）：

| -    | X    | S    |
| ---- | ---- | ---- |
| X    | ×    | ×    |
| S    | ×    | √    |

### 1.5.2 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

<font color="blue">意向锁存在原因</font>：在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS **都是表锁**，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

<font color="blue">意向锁作用</font>：通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

各种锁的兼容关系如下：

| -    | X    | IX   | S    | IS   |
| ---- | ---- | ---- | ---- | ---- |
| X    | ×    | ×    | ×    | ×    |
| IX   | ×    | √    | ×    | √    |
| S    | ×    | ×    | √    | √    |
| IS   | ×    | √    | √    | √    |

解释如下：

- 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；
- S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。

## 1.6 封锁协议

















