# 面试知识点笔记

## 1 右移和无符号右移

x=5,5的二进制是0101。

x=5>>2 （>>带符号右移）

将0101右移2位，为：0001。

y=x>>>2 （>>>无符号右移，左边空缺补充为0）

将0001右移2位，补0。结果为：0000

## 2 Java数字类型相关

Java中整型默认的为int，浮点默认的为double。

float f = 1.1 为错，1.1为double类型，大转小，double不能转为float

int i = 0.0 为错，0.0为double类型,大转小，double不能转为int

Double ddd = 3为错，int无法直接转换为Double

## 3 DBMS特性（持一原隔）

DBMS中有四个特性 ：**持久性**、**一致性**、**原子性**、**隔离性**。

持久性：数据库的恢复，实现恢复管理子系统；

一致性：数据库的并发控制；

原子性：数据库的完整性控制；

隔离性：数据库的安全控制。

## 4 Java类加载器

**引导类加载器（bootstrap class loader）**：用来加载Java的核心库，用原生代码实现。

**扩展类加载器（extensions class loader）**:加载Java的扩展库。

**系统类加载器（system class loader）**:它根据Java应用的类路径（classpath)来加载类。

## 5 实例变量、实例方法、静态变量（类变量）、静态方法（类方法）

**实例成员**包括**实例变量**和**实例方法**，也就是平时说的成员变量和成员方法。

**类成员（静态成员）**包括**静态变量**和**静态方法** ，静态变量也叫做类变量，静态方法也叫做类方法。

在静态方法（类方法）中没有this指针，即不能通过this来调用本类的类方法。

静态变量只能在类主体中定义不能在方法中定义。

## 6 volatile关键字的功能

 **保证可见性** ：

 可见性指的是在一个线程中对该变量的修改会马上由**工作内存**（Work   Memory）写回**主内存**（Main   Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，**工作内存是线程独享的，主存是线程共享的**。 

 **禁止指令重排序优化** ：

禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。

## 7 final知识点

1、final关键字可以用于成员变量、本地变量、方法以及类。

2、 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。

3、 不能够对final变量再次赋值。

4、 本地变量必须在声明时赋值。

5、 在匿名类中所有变量都必须是final变量。

6、 final方法不能被重写。

7、 final类不能被继承。

8、 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。

## 8 Java表达式转型规则

Java表达式转型规则**由低到高转换**： 

  1、所有的byte,short,char型的值将被提升为int型； 

  2、如果有一个操作数是long型，计算结果是long型； 

  3、如果有一个操作数是float型，计算结果是float型； 

  4、如果有一个操作数是double型，计算结果是double型； 

   5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

例如：

```java
byte b1=1,b2=2;
final byte b4=4,b5=5;
byte b3 = b1 + b2; // 错误，b1+b2被转换为int进行计算，算出的结果					  // 为int类型，不能直接赋值给byte类型
byte b6 = b4 + b5; // 正确，final使变量不会自动提升类型（见上）
```

## 9 Java数组复制效率比较

**效率：System.arraycopy() > clone ()> System.copyOf() > for循环** 

## 10 import注意

import java.util.*只能读取java/util目录下的类，不能读取其子目录的类。因为如果java.util里面有个a类，java.util.regex里面也有个A类，我们若是要调用A类的方法或属性时，就不知道调用那个类了。 

## 11 类初始化过程

1.首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 

2.然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 

3.其次，初始化父类的普通成员变量和代码块，再执行父类的构造方法；

4.最后，初始化子类的普通成员变量和代码块，再执行子类的构造方法；

**总体来说就是先静态成员和静态代码块，然后普通成员和代码块，最后构造方法**。

## 12 Byte类型值

 Byte类型值大小为-128~127之间 

如果Byte b = 127；b++；则b==-128；

## 13 null相关

null可以被强制类型转换成任意类型（不是任意类型对象） 

比如：`((A)null).testMethod();`把null转换为A类型，之后调用A的静态方法。

null不属于java.lang.Object类型。

## 14  异常处理相关

程序运行时异常有Java虚拟机自动进行处理

捕获到的异常可以**将异常抛给调用它的上一级方法来处理** 。

## 15 HttpServlet容器响应Web客户请求流程  

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

## 16 ThreadLocal类

1、ThreadLocal的类声明：public class ThreadLocal<T>

可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。

2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立。

3、由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中。

## 17 HashMap、HashTable、Vector、IndetityHashMap继承以及接口

```java
public class Hashtable<K,V> extends Dictionary<K,V>

		implements Map<K,V>, Cloneable, java.io.Serializable

 
public class HashMap<K,V>  extends AbstractMap<K,V>

		implements Map<K,V>, Cloneable, Serializable


public class Vector<E> extends AbstractList<E>

		implements List<E>, RandomAccess, Cloneable, java.io.Serializable


public class IdentityHashMap<K,V> extends AbstractMap<K,V>

		implements Map<K,V>, java.io.Serializable, Cloneable
```

## 18 访问权限控制 

**public>protected>默认(包访问权限)>private** 

![img](https://uploadfiles.nowcoder.com/images/20180815/6855549_1534319281240_994B36FBA5D0176311889BFCC3F57C1F) 

## 19 Java四类八种基本数据类型

第一类：整数类型  byte short int long

第二类：浮点型  float double

第三类：逻辑型  boolean(它只有两个值可取true false)

第四类：字符型  char

## 20 interface变量、方法声明相关

接口中默认修饰变量属性用：public static final；

默认方法的修饰符是：public abstract 

## 21 try{ }、catch{ }、finally{ }返回值的问题

 try{ }中返回了某一个值，如果finally也有return，则finally中的返回值会覆盖try的返回值；如果finally没有返回值，则return try｛｝中缓存的返回值。

## 22 通信的三要素

由**信源**（发端设备）、**信宿**（收端设备）和**信道**（传输媒介）等组成，被称为通信的三要素。

## 23 PPP协议

PPP协议是一种点——**点串行通信协议**。

PPP具有处理错误检测、支持多个协议、允许在连接时刻协商IP地址、允许身份认证等功能，还有其他。PPP提供了3类功能：成帧；链路控制协议LCP；网络控制协议NCP。

PPP是面向**字符类型**的协议。  而HDLC是面向比特的（位）

## 24 网络拓扑结构

物理拓扑结构是星型，逻辑拓扑结构是总线型。

10base是物理上星型结构，逻辑总线型；

100base是逻辑物理都是星型结构。

## 25 String的intern()方法

如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表常量池中这个字符串的String对象；否则创建新String对象并把改字符串添加到常量池，并返回此String对象的引用。

## 26 物理层的特性

- 机械特性——描述接头的形状和尺寸，引线数目和排列；
- 功能特性——接口部件的信号线（数据线、控制线、定时线等）的用途 
- 规程特性——接口部件的信号线在建立、维持、释放物理连接和传输比特流的时序。
- 电气特性——指明什么样的电信号表示0和1；

## 27 数据链路两端的设备

DTE或DCE。

Data Terminal Equipment（DTE），数据终端设备，指具有一定的数据处理能力和数据收发能力的设备。

DCE Data Communications Equipment（数据通信设备）的首字母缩略词，它在DTE和传输线路之间提供信号变换和编码功能，并负责建立、保持和释放链路的连接。

## 28 网络中的各种协议

**FTP**（文件传输协议、File Transfer Protocol）是用于文件传输的Internet标准。FTP支持一些文本文件（例如ASCII、二进制等等）和面向字节流的文件结构。FTP**使用传输层协议TCP**在支持FTP的终端系统间执行文件传输，因此，FTP被认为提供了可靠的面向连接的服务，适合于远距离、可靠性较差线路上的文件传输。

**TFTP**（Trivial File Transfer Protocol，简单文件传输协议）也是用于文件传输，但TFTP**使用UDP**提供服务，被认为是不可靠的，无连接的。TFTP通常用于可靠的局域网内部的文件传输。

**SMTP**（Simple Mail Transfer Protocol。简单邮件传输协议）支持文本**邮件**的Internet传输。

POP3（Post Office Protocol）是一个流行的Internet邮件标准。

SNMP（Simple Network Management Protocol。简单网络管理协议）负责网络设备监控和维护，支持安全管理、性能管理等。

Telnet是客户机使用的与远端服务器建立连接的标准终端仿真协议。

Ping命令是一个诊断网络设备是否正确连接的有效工具。

Tracert命令和Ping命令类似，可以显示数据包经过的每一台网络设备信息，是一个很好的诊断命令。

HTTP协议支持WWW（World Wide Web，万维网）和内部网信息交互，支持包括视频在内的多种文件类型。HTTP是当今流行的Internet标准。

DNS（Domain Name System，域名系统）把网络节点的易于记忆的名字转化为网络地址。

WINS（Windows Internet Name Server，Windows Internet命名服务器），此服务可以将NetBIOS 名称注册并解析为网络上使用的IP地址。

BootP（Bootstrap Protocol，引导协议）是使用传输层UDP协议动态获得IP地址的协议。

## 29 各个层的数据单元

- 应用层：数据
- 传输层：数据段
- 网络层：数据包
- 网络接口层：帧

## 30ARP协议(地址解析协议)

- ARP:IP地址到物理地址
- DNS:域名到IP地址

## 31 缺省子网掩码

- A类地址：255.0.0.0
- B类地址：255.255.0.0
- C类地址：255.255.255.0

## 32 子类构造器，父类构造器之间的问题

在调用子类构造器之前，会先调用父类构造器。

当子类构造器中**没有使用"super**(参数或无参数)"指定调用父类构造器时，是**默认调用父类的无参构造器**，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。

## 33 Spring依赖注入的三种方式

- 接口注入
- setter方法注入
- 构造方法注入

## 34 Thread.sleep()抛出的异常

将会抛出InterruptedException异常。

## 35















                                                                                                                                                                                                                                                                                                                               

























