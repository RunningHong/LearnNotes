# 面试知识点笔记

## 1 右移和无符号右移

x=5,5的二进制是0101。

x=5>>2 （>>带符号右移）

将0101右移2位，为：0001。

y=x>>>2 （>>>无符号右移，左边空缺补充为0）

将0001右移2位，补0。结果为：0000

## 2 Java数字类型相关

Java中整型默认的为int，浮点默认的为double。

float f = 1.1 为错，1.1为double类型，大转小，double不能转为float

int i = 0.0 为错，0.0为double类型,大转小，double不能转为int

Double ddd = 3为错，int无法直接转换为Double

## 3 DBMS特性（持一原隔）

DBMS中有四个特性 ：**持久性**、**一致性**、**原子性**、**隔离性**。

持久性：数据库的恢复，实现恢复管理子系统；

一致性：数据库的并发控制；

原子性：数据库的完整性控制；

隔离性：数据库的安全控制。

## 4 Java类加载器

**引导类加载器（bootstrap class loader）**：用来加载Java的核心库，用原生代码实现。

**扩展类加载器（extensions class loader）**:加载Java的扩展库。

**系统类加载器（system class loader）**:它根据Java应用的类路径（classpath)来加载类。

## 5 实例变量、实例方法、静态变量（类变量）、静态方法（类方法）

**实例成员**包括**实例变量**和**实例方法**，也就是平时说的成员变量和成员方法。

**类成员（静态成员）**包括**静态变量**和**静态方法** ，静态变量也叫做类变量，静态方法也叫做类方法。

在静态方法（类方法）中没有this指针，即不能通过this来调用本类的类方法。

静态变量只能在类主体中定义不能在方法中定义。

## 6 volatile关键字的功能

​	 **保证可见性** ：

​      可见性指的是在一个线程中对该变量的修改会马上由**工作内存**（Work   Memory）写回**主内存**（Main   Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，**工作内存是线程独享的，主存是线程共享的**。 

​	 **禁止指令重排序优化** ：

​        禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。

## 7 final知识点

1、final关键字可以用于成员变量、本地变量、方法以及类。

2、 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。

3、 你不能够对final变量再次赋值。

4、 本地变量必须在声明时赋值。

5、 在匿名类中所有变量都必须是final变量。

6、 final方法不能被重写。

7、 final类不能被继承。

8、 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。

## 8 Java表达式转型规则

Java表达式转型规则**由低到高转换**： 

  1、所有的byte,short,char型的值将被提升为int型； 

  2、如果有一个操作数是long型，计算结果是long型； 

  3、如果有一个操作数是float型，计算结果是float型； 

  4、如果有一个操作数是double型，计算结果是double型； 

   5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

​	例如：

```java
byte b1=1,b2=2;
final byte b4=4,b5=5;
byte b3 = b1 + b2; // 错误，b1+b2被转换为int进行计算，算出的结果					  // 为int类型，不能直接赋值给byte类型
byte b6 = b4 + b5; // 正确，final使变量不会自动提升类型（见上）
```

## 9 Java数组复制效率比较

**效率：System.arraycopy() > clone ()> System.copyOf() > for循环** 

## 10 import注意

import java.util.*只能读取java/util目录下的类，不能读取其子目录的类。因为如果java.util里面有个a类，java.util.regex里面也有个A类，我们若是要调用A类的方法或属性时，就不知道调用那个类了。 

## 11 类初始化过程

1.首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 

2.然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 

3.其次，初始化父类的普通成员变量和代码块，在执行父类的构造方法；

4.最后，初始化子类的普通成员变量和代码块，在执行子类的构造方法；

## 12 Byte类型值

 Byte类型值大小为-128~127之间 

如果Byte b = 127；b++；则b==-128；

## 13 null相关

null可以被强制类型转换成任意类型（不是任意类型对象） 

比如：`((A)null).testMethod();`把null转换为A类型，之后调用A的静态方法。

null不属于java.lang.Object类型。

## 14  异常处理相关

程序运行时异常有Java虚拟机自动进行处理

捕获到的异常可以**将异常抛给调用它的上一级方法来处理** 。

## 15 HttpServlet容器响应Web客户请求流程  

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

## 16 ThreadLocal类

1、ThreadLocal的类声明：public class ThreadLocal<T>

可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。

2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立。

3、由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中。

## 17 HashMap、HashTable、Vector、IndetityHashMap继承以及接口

```java
public class Hashtable<K,V> extends Dictionary<K,V>

		implements Map<K,V>, Cloneable, java.io.Serializable

 
public class HashMap<K,V>  extends AbstractMap<K,V>

		implements Map<K,V>, Cloneable, Serializable


public class Vector<E> extends AbstractList<E>

		implements List<E>, RandomAccess, Cloneable, java.io.Serializable


public class IdentityHashMap<K,V> extends AbstractMap<K,V>

		implements Map<K,V>, java.io.Serializable, Cloneable
```

## 18 访问权限控制 

**public>protected>默认(包访问权限)>private** 

![img](https://uploadfiles.nowcoder.com/images/20180815/6855549_1534319281240_994B36FBA5D0176311889BFCC3F57C1F) 

## 19

























