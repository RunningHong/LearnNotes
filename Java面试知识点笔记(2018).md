# 面试知识点笔记

## 1 右移和无符号右移

x=5,5的二进制是0101。

x=5>>2 （>>带符号右移）

将0101右移2位，为：0001。

y=x>>>2 （>>>无符号右移，左边空缺补充为0）

将0001右移2位，补0。结果为：0000

## 2 Java数字类型相关

Java中整型默认的为int，浮点默认的为double。

float f = 1.1 为错，1.1为double类型，大转小，double不能转为float

int i = 0.0 为错，0.0为double类型,大转小，double不能转为int

Double ddd = 3为错，int无法直接转换为Double

## 3 DBMS特性（持一原隔）

DBMS中有四个特性 ：**持久性**、**一致性**、**原子性**、**隔离性**。

持久性：数据库的恢复，实现恢复管理子系统；

一致性：数据库的并发控制；

原子性：数据库的完整性控制；

隔离性：数据库的安全控制。

## 4 Java类加载器

**启动类加载器（bootstrap class loader）**：用来加载Java的核心库，用原生代码实现。

**扩展类加载器（extensions class loader）**:加载Java的扩展库。

**应用程序加载器/系统类加载器（system class loader）**:它根据Java应用的类路径（classpath)来加载类。

说到类加载器那么就要谈谈类加载器之间的关系，加载器之间的关系称作为**双亲委派模型**（除了bootstrap ClassLoader外，其他的类加载器都有自己的父类加载器，类加载器都是使用组合关系来复用父类加载器的代码）

**双亲委派模型**工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器都是这样的，因此所有的加载器请求最终都应该传送到顶层的启动类加载器，之后当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

## 5 实例变量、实例方法、静态变量（类变量）、静态方法（类方法）

**实例成员**包括**实例变量**和**实例方法**，也就是平时说的成员变量和成员方法。

**类成员（静态成员）**包括**静态变量**和**静态方法** ，静态变量也叫做类变量，静态方法也叫做类方法。

在静态方法（类方法）中没有this指针，即不能通过this来调用本类的类方法。

静态变量只能在类主体中定义不能在方法中定义。

## 6 volatile关键字的功能

 **保证可见性** ：

可见性指的是在一个线程中对该变量的修改会马上由**工作内存**（Work   Memory）写回**主内存**（Main   Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，**工作内存是线程独享的，主存是线程共享的**。 

 **禁止指令重排序优化** ：

禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。

## 7 final知识点

1、final关键字可以用于成员变量、本地变量、方法以及类。

2、 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。

3、 不能够对final变量再次赋值。

4、 本地变量必须在声明时赋值。

5、 在匿名类中所有变量都必须是final变量。

6、 final方法不能被重写。

7、 final类不能被继承。

8、 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。

## 8 Java表达式转型规则

Java表达式转型规则**由低到高转换**： 

  1、所有的byte,short,char型的值将被提升为int型； 

  2、如果有一个操作数是long型，计算结果是long型； 

  3、如果有一个操作数是float型，计算结果是float型； 

  4、如果有一个操作数是double型，计算结果是double型； 

   5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

例如：

```java
byte b1=1,b2=2;
final byte b4=4,b5=5;
byte b3 = b1 + b2; // 错误，b1+b2被转换为int进行计算，算出的结果					  // 为int类型，不能直接赋值给byte类型
byte b6 = b4 + b5; // 正确，final使变量不会自动提升类型（见上）
```

## 9 Java数组复制效率比较

**效率：System.arraycopy() > clone ()> System.copyOf() > for循环** 

## 10 import注意

import java.util.*只能读取java/util目录下的类，不能读取其子目录的类。因为如果java.util里面有个a类，java.util.regex里面也有个A类，我们若是要调用A类的方法或属性时，就不知道调用那个类了。 

## 11 类初始化过程

1.首先，初始化**父类中的静态成员变量和静态代码块**，按照在程序中出现的顺序初始化； 

2.然后，初始化**子类中的静态成员变量和静态代码块**，按照在程序中出现的顺序初始化； 

3.其次，初始化**父类的普通成员变量和代码块**，再执行**父类的构造方法**；

4.最后，初始化**子类的普通成员变量和代码块**，再执行**子类的构造方法**；

## 12 Byte类型值

 Byte类型值大小为-128~127之间 

如果Byte b = 127；b++；则b==-128；

## 13 null相关

null可以被强制类型转换成任意类型（不是任意类型对象） 

比如：`((A)null).testMethod();`把null转换为A类型，之后调用A的静态方法。

null不属于java.lang.Object类型。

## 14  异常处理相关

程序运行时异常有Java虚拟机自动进行处理

捕获到的异常可以**将异常抛给调用它的上一级方法来处理** 。

## 15 HttpServlet容器响应Web客户请求流程  

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

## 16 ThreadLocal类

1、ThreadLocal的类声明：public class ThreadLocal<T>

可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。

2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立。

3、由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中。

## 17 HashMap、HashTable、Vector、IndetityHashMap继承以及接口

```java
public class Hashtable<K,V> extends Dictionary<K,V>

		implements Map<K,V>, Cloneable, java.io.Serializable

 
public class HashMap<K,V>  extends AbstractMap<K,V>

		implements Map<K,V>, Cloneable, Serializable


public class Vector<E> extends AbstractList<E>

		implements List<E>, RandomAccess, Cloneable, java.io.Serializable


public class IdentityHashMap<K,V> extends AbstractMap<K,V>

		implements Map<K,V>, java.io.Serializable, Cloneable
```

## 18 访问权限控制 

**public>protected>默认(包访问权限)>private** 

![img](https://uploadfiles.nowcoder.com/images/20180815/6855549_1534319281240_994B36FBA5D0176311889BFCC3F57C1F) 

## 19 Java四类八种基本数据类型

第一类：整数类型  byte short int long

第二类：浮点型  float double

第三类：逻辑型  boolean(它只有两个值可取true false)

第四类：字符型  char

## 20 interface变量、方法声明相关

接口中默认修饰变量属性用：public static final；

默认方法的修饰符是：public abstract 

## 21 try{ }、catch{ }、finally{ }返回值的问题

 try{ }中返回了某一个值，如果finally也有return，则finally中的返回值会覆盖try的返回值；如果finally没有返回值，则return try｛｝中缓存的返回值。

## 22 通信的三要素

由**信源**（发端设备）、**信宿**（收端设备）和**信道**（传输媒介）等组成，被称为通信的三要素。

## 23 PPP协议

PPP协议是一种点——**点串行通信协议**。

PPP具有处理错误检测、支持多个协议、允许在连接时刻协商IP地址、允许身份认证等功能，还有其他。PPP提供了3类功能：成帧；链路控制协议LCP；网络控制协议NCP。

PPP是面向**字符类型**的协议。  而HDLC是面向比特的（位）

## 24 网络拓扑结构

物理拓扑结构是星型，逻辑拓扑结构是总线型。

10base是物理上星型结构，逻辑总线型；

100base是逻辑物理都是星型结构。

## 25 String的intern()方法

如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表常量池中这个字符串的String对象；否则创建新String对象并把改字符串添加到常量池，并返回此String对象的引用。

## 26 物理层的特性

- 机械特性——描述接头的形状和尺寸，引线数目和排列；
- 功能特性——接口部件的信号线（数据线、控制线、定时线等）的用途 
- 规程特性——接口部件的信号线在建立、维持、释放物理连接和传输比特流的时序。
- 电气特性——指明什么样的电信号表示0和1；

## 27 数据链路两端的设备

DTE或DCE。

Data Terminal Equipment（DTE），数据终端设备，指具有一定的数据处理能力和数据收发能力的设备。

DCE Data Communications Equipment（数据通信设备）的首字母缩略词，它在DTE和传输线路之间提供信号变换和编码功能，并负责建立、保持和释放链路的连接。

## 28 网络中的各种协议

**FTP**（文件传输协议、File Transfer Protocol）是用于文件传输的Internet标准。FTP支持一些文本文件（例如ASCII、二进制等等）和面向字节流的文件结构。FTP**使用传输层协议TCP**在支持FTP的终端系统间执行文件传输，因此，FTP被认为提供了可靠的面向连接的服务，适合于远距离、可靠性较差线路上的文件传输。

**TFTP**（Trivial File Transfer Protocol，简单文件传输协议）也是用于文件传输，但TFTP**使用UDP**提供服务，被认为是不可靠的，无连接的。TFTP通常用于可靠的局域网内部的文件传输。

**SMTP**（Simple Mail Transfer Protocol。简单邮件传输协议）支持文本**邮件**的Internet传输。

POP3（Post Office Protocol）是一个流行的Internet邮件标准。

SNMP（Simple Network Management Protocol。简单网络管理协议）负责网络设备监控和维护，支持安全管理、性能管理等。

Telnet是客户机使用的与远端服务器建立连接的标准终端仿真协议。

Ping命令是一个诊断网络设备是否正确连接的有效工具。

Tracert命令和Ping命令类似，可以显示数据包经过的每一台网络设备信息，是一个很好的诊断命令。

HTTP协议支持WWW（World Wide Web，万维网）和内部网信息交互，支持包括视频在内的多种文件类型。HTTP是当今流行的Internet标准。

DNS（Domain Name System，域名系统）把网络节点的易于记忆的名字转化为网络地址。

WINS（Windows Internet Name Server，Windows Internet命名服务器），此服务可以将NetBIOS 名称注册并解析为网络上使用的IP地址。

BootP（Bootstrap Protocol，引导协议）是使用传输层UDP协议动态获得IP地址的协议。

## 29 各个层的数据单元

- 应用层：数据
- 传输层：数据段
- 网络层：数据包
- 网络接口层：帧

## 30 ARP协议(地址解析协议)

- ARP:IP地址到物理地址
- DNS:域名到IP地址

## 31 缺省子网掩码

- A类地址：255.0.0.0
- B类地址：255.255.0.0
- C类地址：255.255.255.0

## 32 子类构造器，父类构造器之间的问题

在调用子类构造器之前，会先调用父类构造器。

当子类构造器中**没有使用"super**(参数或无参数)"指定调用父类构造器时，是**默认调用父类的无参构造器**，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。

## 33 Spring依赖注入的三种方式

- 接口注入
- setter方法注入
- 构造方法注入

## 34 Thread.sleep()抛出的异常

将会抛出InterruptedException异常。

## 35 Thread中join()方法的作用

join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。

## 36 静态内部类和非静态内部类的区别

1. 静态内部类可以不依赖与外部类实例被实例化，非静态内部类需要在外部类被实例化后才能被实例化。
2. 内部类不能直接访问外部类的成员，除非是静态内部类访问外部类的静态成员。
3. 静态内部类可以有静态成员，非静态内部类不能有静态成员。
4. 非静态内部类的非静态成员可以访问外部类的非静态变量。

## 37 JVM判断两个类是否相同

- 类的全称
- 类加载器

类全称和类加载器一起来判断两个类是否相同。

## 38 Interface是否继承Object类

首先interface不会有继承，interface只有实现没有继承，其实Interface是实现了一个Object接口。

## 39依赖注入&控制反转

依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。

**依赖注入**是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；

**控制反转**是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。

## 40 是否可以释放掉一个指定占据的内存空间

不可以，在Java虚拟机中明确的指出，释放占据的内存室友GC完成的，程序员无法明确强制其运行，而且释不释放取决于GC，无法由程序员通过代码控制，调用System.gc(),不会马上机型垃圾回收。

## 41 JSP内置对象

1、pageContext 表示页容器 EL表达式、 标签 、上传 
2、request 服务器端取得客户端的信息：头信息 、Cookie 、请求参数 
3、response 服务器端回应客户端信息：Cookie、重定向 
4、session 表示每一个用户，用于登录验证上 
5、application 表示整个服务器 
6、config 取得初始化参数，初始化参数在web.xml文件中配置 
7、exception 表示的是错误页的处理操作 
8、page 如同this一样，代表整个jsp页面自身 
9、out 输出 ，但是尽量使用表达式输出

## 42 Java Unicode相关

Java默认的字符集是Unicode（占两个字节byte，一个字节==8个比特位，所以Unicode占用16位）

## 43 抛InterruptedException的代表方法

- java.lang.Object 类的 wait 方法
- java.lang.Thread 类的 sleep 方法
- java.lang.Thread 类的 join 方法

## 44 字节流、字符流

字节流继承于InputStream、OutputStream

字符流继承于InputStreamReader、OutputStreamWriter

**字节流**：

InputStream

|-- FileInputStream (基本文件流）

|-- BufferedInputStream

|-- DataInputStream

|-- ObjectInputStream

**字符流**：

Reader 
|-- InputStreamReader (byte->char 桥梁） 
|-- BufferedReader (常用） 
Writer 
|-- OutputStreamWriter (char->byte 桥梁） 
|-- BufferedWriter 
|-- PrintWriter （常用）

## 45 LinkedBlockingQueue相关

**LinkedBlockingQueue**：基于链接节点的可选限定的blocking queue 。 这个队列排列元素FIFO（先进先出）。 队列的头部是队列中最长的元素。 队列的尾部是队列中最短时间的元素。 新元素插入队列的尾部，队列检索操作获取队列头部的元素。 链接队列通常具有比基于阵列的队列更高的吞吐量，但在大多数并发应用程序中的可预测性能较低。

**blocking queue说明**：不接受null元素；可能是容量有限的；实现被设计为主要用于生产者 - 消费者队列；不支持任何类型的“关闭”或“关闭”操作，表示不再添加项目实现是线程安全的；

## 46 常用ASCII码

‘0’对应48、‘A’对应68、‘a’对应97、空格对应160

## 47 事务属性的种类

包括**传播行为、隔离级别、只读和事务超时**。

1. **传播行为**：定义了被调用方法的事务边界。
2. **隔离级别**：在操作数据时可能带来3个副作用，分别是**脏读**、**不可重复读**、**幻读**。为了避免这三个副作用的发生，在标准的SQL语句中定义了4种隔离级别，分别是**未提交读**、**已提交读**、**可重复读**、**可序列化**。
3. **只读**：只读代表着所有的操作只读取数据库中的数据，而并不是更新数据。
4. **事务超时**：如果一个事务长时间运行，这是为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。

## 48 wait和notify

wait方法使线程进入等待锁定池，只有针对此对象发出notify方法获得对象锁进入就绪状态。

## 49 假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为

答案：this(x)，注意不是this.A(x),也不是A(X)

## 50 Java用()机制实现了进程之间的同步执行

答案：监视器。

在jvm中是使用**监视器锁**来实现不同线程的异步执行，在语法的表现就是**synchronized**  。









                                                                                                                                                                                                                                                                                                                               

























