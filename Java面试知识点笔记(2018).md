# 面试知识点笔记

## 1 右移和无符号右移

x=5,5的二进制是0101。

x=5>>2 （>>带符号右移）

将0101右移2位，为：0001。

y=x>>>2 （>>>无符号右移，左边空缺补充为0）

将0001右移2位，补0。结果为：0000

## 2 Java数字类型相关

Java中整型默认的为int，浮点默认的为double。

float f = 1.1 为错，1.1为double类型，大转小，double不能转为float

int i = 0.0 为错，0.0为double类型,大转小，double不能转为int

Double ddd = 3为错，int无法直接转换为Double

## 3 DBMS特性（持一原隔）

DBMS中有四个特性 ：**持久性**、**一致性**、**原子性**、**隔离性**。

持久性：数据库的恢复，实现恢复管理子系统；

一致性：数据库的并发控制；

原子性：数据库的完整性控制；

隔离性：数据库的安全控制。

## 4 Java类加载器

**引导类加载器（bootstrap class loader）**：用来加载Java的核心库，用原生代码实现。

**扩展类加载器（extensions class loader）**:加载Java的扩展库。

**系统类加载器（system class loader）**:它根据Java应用的类路径（classpath)来加载类。

## 5 实例变量、实例方法、静态变量（类变量）、静态方法（类方法）

**实例成员**包括**实例变量**和**实例方法**，也就是平时说的成员变量和成员方法。

**类成员（静态成员）**包括**静态变量**和**静态方法** ，静态变量也叫做类变量，静态方法也叫做类方法。

在静态方法（类方法）中没有this指针，即不能通过this来调用本类的类方法。

## 6 volatile关键字的功能

​	 **保证可见性** ：

​      可见性指的是在一个线程中对该变量的修改会马上由**工作内存**（Work   Memory）写回**主内存**（Main   Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，**工作内存是线程独享的，主存是线程共享的**。 

​	 **禁止指令重排序优化** ：

​        禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。

## 7 final知识点

1、final关键字可以用于成员变量、本地变量、方法以及类。

2、 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。

3、 你不能够对final变量再次赋值。

4、 本地变量必须在声明时赋值。

5、 在匿名类中所有变量都必须是final变量。

6、 final方法不能被重写。

7、 final类不能被继承。

8、 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。

## 8 Java表达式转型规则

Java表达式转型规则**由低到高转换**： 

  1、所有的byte,short,char型的值将被提升为int型； 

  2、如果有一个操作数是long型，计算结果是long型； 

  3、如果有一个操作数是float型，计算结果是float型； 

  4、如果有一个操作数是double型，计算结果是double型； 

   5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

​	例如：

```java
byte b1=1,b2=2;
final byte b4=4,b5=5;
byte b3 = b1 + b2; // 错误，b1+b2被转换为int进行计算，算出的结果					  // 为int类型，不能直接赋值给byte类型
byte b6 = b4 + b5; // 正确，final使变量不会自动提升类型（见上）
```

## 9 Java数组复制效率比较

**效率：System.arraycopy() > clone ()> System.copyOf() > for循环** 

## 10 import注意

import java.util.*只能读取java/util目录下的类，不能读取其子目录的类。因为如果java.util里面有个a类，java.util.regex里面也有个A类，我们若是要调用A类的方法或属性时，就不知道调用那个类了。 

## 11 







