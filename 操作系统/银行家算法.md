# 1 银行家算法

操作系统的进程可以动态地申请资源，但系统在进行资源分配之前，应先计算此次**资源分配的安全性**。（若此次分配为**安全**的，操作系统则将资源分配给进程，否则令进程等待）

避免死锁的实质在于：<font color="red">系统在进行资源分配时，如何使系统不进入不安全状态。</font>

## 1.1 举例理解

**战争举例**：

**大将军**（操作系统）有一个**部队**（代分配的资源），当然部队中有各种**兵种**（弓箭手、骑兵等，每个兵种就能完成特定的战争）人有若干（人数固定，大将军也只有这点兵），现在在我方的**城池**（很多个城池，当然每个城池每个兵种都有一定的人驻扎在这里，已分配的资源）有敌方突袭（每个城池都僵持着，没战胜敌方之前不能从这个城池把各个兵种的人撤走），这时每个城池都给大将军发出了能战胜敌方每个兵种的**需求数量**（Need），大将军就来判断怎样才能结束战斗（所有的城池都战胜敌方），当大将军发现某个城池在他的加入后能够战胜敌方就参与其中，如果战胜了敌方那么就可以把原来驻扎在这个城池的各个兵种调走，去支援其他的城池。周而复始通过边打仗边收兵，来使所有的城池和平。

**银行家算法就是来判断能否赢取整个战争。**



## 1.2 银行家算法的数据结构（以例子作为出发点）

1. <font color="blue">可利用资源向量Available</font>（**代表大将军的部队，部队中各个兵种的人有若干个**）
   这是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果Available[j]=K，则表示系统中现有Rj类资源K个。

2. <font color="blue">最大需求矩阵Max</font>（**代表一个城池中能够战胜敌方每个兵种需要全部的数量**）
   这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。

3. <font color="blue">分配矩阵Allocation</font>（**代表城池中已经驻扎的各个兵种的数量**）
   这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得R j类资源的数目为K。

4. <font color="blue">需求矩阵Need</font>（**代表城池发送给大将军每个兵种需要支援的数量**）

   这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要R j类资源K个，方能完成其任务。

存在关系：Need[i, j]=Max[i, j]-Allocation[i, j]；（**城池的发出请求每个兵种的数量 = 战胜敌方所需每个兵种数量 - 城池中已有每个兵种数量**）



## 1.3 银行家算法实例

假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图示。 （先忽略P1第二行的括号）

![](https://github.com/RunningHong/LearnNotes/blob/master/picture/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8Bupdate.png?raw=true)

<font color="blue">描述</font>：有若干城池（P0 --- P4）,大将军有可利用的每个兵种的人数**Available**（3,3,2），就拿P0来说，P0解决战斗每个兵种的需要的总人数**Max**（7,5,3），在城池中每个兵种已经有的人数**Allocation**（0,1,0），P0完成这场斗争需要的兵的数量**Need**（7,4,3）【Need[i]=Max[i]-Allocation[i]】

<font color="blue">解决步骤</font>：首先大将军比较P0发现直接的兵**Available**（3,3,2），不能满足P0的需求**Need**（7,4,3），于是走到下一个城池P0,发现可以打赢这场战争，于是战斗解放了城池，因此部队也得到了增强到**Available**（5,3,2），依次类推寻找可以战胜战争的城池，获得最终的胜利
















