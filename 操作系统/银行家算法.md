# 1 银行家算法

操作系统的进程可以动态地申请资源，但系统在进行资源分配之前，应先计算此次**资源分配的安全性**。（若此次分配为**安全**的，操作系统则将资源分配给进程，否则令进程等待）

避免死锁的实质在于：<font color="red">系统在进行资源分配时，如何使系统不进入不安全状态。</font>

## 1.1 举例理解

**战争举例**：

**大将军**（操作系统）有一个**部队**（代分配的资源），当然部队中有各种**兵种**（弓箭手、骑兵等，每个兵种就能完成特定的战争）人有若干（人数固定，大将军也只有这点兵），现在在我方的**城池**（很多个城池，当然每个城池每个兵种都有一定的人驻扎在这里，已分配的资源）有敌方突袭（每个城池都僵持着，没战胜敌方之前不能从这个城池把各个兵种的人撤走），这时每个城池都给大将军发出了能战胜敌方每个兵种的**需求数量**（Need），大将军就来判断怎样才能结束战斗（所有的城池都战胜敌方），当大将军发现某个城池在他的加入后能够战胜敌方就参与其中，如果战胜了敌方那么就可以把原来驻扎在这个城池的各个兵种调走，去支援其他的城池。周而复始通过边打仗边收兵，来使所有的城池和平。

**银行家算法就是来判断能否赢取整个战争。**



## 1.2 银行家算法的数据结构（以例子作为出发点）

1. <font color="blue">可利用资源向量Available</font>（**代表大将军的部队，部队中各个兵种的人有若干个**）
   这是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果Available[j]=K，则表示系统中现有Rj类资源K个。

2. <font color="blue">最大需求矩阵Max</font>（**代表一个城池中能够战胜敌方每个兵种需要全部的数量**）
   这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。

3. <font color="blue">分配矩阵Allocation</font>（**代表城池中已经驻扎的各个兵种的数量**）
   这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得R j类资源的数目为K。

4. <font color="blue">需求矩阵Need</font>（**代表城池发送给大将军每个兵种需要支援的数量**）

   这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要R j类资源K个，方能完成其任务。

存在关系：Need[i, j]=Max[i, j]-Allocation[i, j]；（**城池的发出请求每个兵种的数量 = 战胜敌方所需每个兵种数量 - 城池中已有每个兵种数量**）




















