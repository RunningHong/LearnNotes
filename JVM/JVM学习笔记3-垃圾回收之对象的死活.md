摘自《深入理解Java虚拟机》第二版

# 1 对象的死活

## 1.1 引用计数算法

	**引用计数法算**：给对象添加一个**引用计数器**，每当一个地方引用它是，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

	但在主流的Java虚拟机中并没有选择引用计数算法来管理内存，其中最主要的原因是它**很难解决对象间相互循环引用的问题**，比如：在对象A和对象B中都有字段instance，令A.instance = B和B.instance = A,这两个对象再无任何引用，实际上这两个对象已经不可能再访问，但因为互相引用这对方，导致引用计数器始终不为0，艺术易用计数器算法无法通知GC收集器回收它们。

## 1.2 可达性分析算法

	**基本思路**：通过一系列称为“**GC Roots**”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（**用图论的话来说就是从GC Roots**

**到这个对象不可达**）时，则证明此对象引用不可用，此时就会被判定为可回收对象。

	在Java中，可作为GC Roots的对象包括下面几种：

	1.虚拟机栈（栈帧中的本地变量表）中引用的对象。

	2.方法区中静态属性引用的对象。

	3.方法区中常量引用的对象。

	4.本地方法中JNI（即一般说的Native方法）引用的对象。

## 1.3 再谈引用（强引用、软引用、弱引用、虚引用）

	引用分为强引用、软引用、弱引用、虚引用，这四种引用强度一次逐渐减弱。

- **强引用(Strong Reference)**指的就是程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器就**永远不会回收**掉被引用的对象。
- **软引用(Soft Reference)**用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列经回收范围之中进行**第二次回收**。如果第二次回收还没有足够的内存，才会抛出内存溢出异常。
- **弱引用(Weak Reference)**用来描述非必须对象，但它的引用强度比软引用更弱，被软引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，**都会回收**掉只被弱引用关联的对象。
- **虚引用(Phantom Reference)**也称为幽灵引用或幻影引用，它是最弱的一种引用关系。**一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例**。为一个对象设置虚引用关联的唯一目的就是在这个对象被收集器回收时收到一个系统通知。

## 1.4 生存还是死亡

	



