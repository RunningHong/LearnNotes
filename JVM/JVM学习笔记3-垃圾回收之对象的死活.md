摘自《深入理解Java虚拟机》第二版

# 1 对象的死活

## 1.1 引用计数算法

**引用计数法算**：给对象添加一个**引用计数器**，每当一个地方引用它是，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

但在主流的Java虚拟机中并没有选择引用计数算法来管理内存，其中最主要的原因是它**很难解决对象间相互循环引用的问题**，比如：在对象A和对象B中都有字段instance，令A.instance = B和B.instance = A,这两个对象再无任何引用，实际上这两个对象已经不可能再访问，但因为互相引用这对方，导致引用计数器始终不为0，艺术易用计数器算法无法通知GC收集器回收它们。

## 1.2 可达性分析算法

**基本思路**：通过一系列称为“**GC Roots**”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（**用图论的话来说就是从GC Roots**

**到这个对象不可达**）时，则证明此对象引用不可用，此时就会被判定为可回收对象。

在Java中，可作为GC Roots的对象包括下面几种：

1.虚拟机栈（栈帧中的本地变量表）中引用的对象。

2.方法区中静态属性引用的对象。

3.方法区中常量引用的对象。

4.本地方法中JNI（即一般说的Native方法）引用的对象。

## 1.3 再谈引用（强引用、软引用、弱引用、虚引用）

引用分为强引用、软引用、弱引用、虚引用，这四种引用强度一次逐渐减弱。

- **强引用(Strong Reference)**指的就是程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器就**永远不会回收**掉被引用的对象。
- **软引用(Soft Reference)**用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列经回收范围之中进行**第二次回收**。如果第二次回收还没有足够的内存，才会抛出内存溢出异常。
- **弱引用(Weak Reference)**用来描述非必须对象，但它的引用强度比软引用更弱，被软引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，**都会回收**掉只被弱引用关联的对象。
- **虚引用(Phantom Reference)**也称为幽灵引用或幻影引用，它是最弱的一种引用关系。**一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例**。为一个对象设置虚引用关联的唯一目的就是在这个对象被收集器回收时收到一个系统通知。

## 1.4 生存还是死亡(finalize方法)

即使在可达性分析算法中不可达的对象，也并非是非死不可的，要真正宣告一个对象死亡，至少要经历**两次标记**过程：**如果对象在进行可达性分析后发现没有GC Roots相链接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法**。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行操作。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()方法中成功解救自己，只需要重新与引用链上的任何一个对象建立关联即可，这样在第二次标记时它将被溢出“即将收回”的集合；如果对象这个时候还没有逃脱，那基本上它就真的被回收了。

**任何一个对象的finalize()方法都只会被系统自动调用一次**，如果执行了一次，那么下一次对象面临回收时，它的finalize()方法将不会执行。finalize()方法并不被提倡使用，它的运行代价很高，不确定大，无法保证各个对象的调用顺序。

