[TOC]

摘自《鸟哥的Linux私房菜 - 基础学习篇》

# Bash学习

## 1 Shell的变量功能

### 1.1 读取变量（echo）

 `echo $变量名` 或者 `echo ${变量名}` 取变量

比如：取出环境变量HOME为 `echo $HOME` 或者 `echo ${HOME}`

`echo “显示内容”` 相当于打印显示内容。

### 1.2 设定变量（=）

```shell
echo $myName
myName=ddd
```

这里把myName这个变量设为了ddd。

### 1.3 变量的设定规则

- 变量与变量值通过 `=` 连接， 如 `myName=ddd` 。
- **等号两边不能直接接空格** 。（`myName = ddd`，`myName=zh ho` 都是不允许的）
- 变量名称只能是英文字母与数字，但是开头只能是字母。（~~2MyName=ddd~~是不允许的）
- 变量内容有空格使用 `''` 或者 `""` 来包含变量值，如 `myName="zhang hong"`
- 使用转义字符 `\` 将特殊符号（Enter，$, \ , 空格）转换为一般字符。
- 在一串指令中还需借用其他指令提供的信息，可以使用反单引号 （ESC下面的符号），或者使用 `$(指令)` 。
  如： `version=$(uname -r)`
- 若该变量需在这个变量上扩展内容时，可用 `$变量名称` 或者 `${变量}` 累加内容，如： `PATH="$PATH":/home/bin`
- 若变量需要在其他子程序执行，则需要使用 `export` 来使变量变为**环境变量** ，如：`exprot PATH`
- 取消变量使用 `unset 变量名称` ，如： `unset myName`

### 1.4 环境变量的功能

- 用 `env` 观察环境变量与常见环境变量说明（就是 `env` 之后敲回车）
- 用 `set` 观察所用变量（含环境变量与自定义变量）。

## 2 命令别名设定（alias，unalias）

为了简化我们的操作，我们可以给常用的命令设置别名，就像window在桌面设置一个快捷方式一样。

```shell
# 使用 `lm` 作为 `ls -al | more` 的快捷键:
[root@www ~]# alias lm='ls -al | more'

# 取消 `lm` 这个命令别名：
[root@www ~]# unalias lm

# 当我们把命令和别名取成一样（如：alias ls=ls -al）,我们想使用原先的ls而不是别名，需要使用\
[root@www ~]# \ls
```



## 3 bash组合键

| 按键       | 执行结果                           |
| ---------- | ---------------------------------- |
| `Ctrl + C` | 终止当前命令                       |
| `Ctrl + D` | 输入结束 (EOF)，例如邮件结束的时候 |
| `Ctrl + M` | 就是 Enter 啦！                    |
| `Ctrl + S` | 暂停屏幕的输出                     |
| `Ctrl + Q` | 恢复屏幕的输出                     |
| `Ctrl + U` | 在提示字符下，将整列命令删除       |
| `Ctrl + Z` | 『暂停』目前的命令                 |

## 4 通配符与特殊符号（常用）

| 符号  | 意义                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 代表 **0 个到无穷多个**任意字符                              |
| ?     | 代表**一个**任意字符                                         |
| [ ]   | 同样代表**一定有一个在括号内**的字符(非任意字符)。<br />例如 `[abcd]` 代表一定有一个字符， 可能是 a, b, c, d 这四个任何一个 |
| [ - ] | 若有减号在中括号内时，代表**在编码顺序内的所有字符**。<br />例如 `[0-9]` 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！ |
| [ ^ ] | 若中括号内的第一个字符为 (^) ，那表示**过滤选择** （不选取）。<br />例如 `^abc` 代表只要是非 a, b, c 的其他字符就接受。 |

举例：

```shell
[root@www ~]# LANG=C <==由于与编码有关，先设定一下语系

范例一：找出 /etc/ 底下以 cron 为开头的档名
[root@www ~]# ll -d /etc/cron* <==加上 -d 是为了仅显示目录而已

范例二：找出 /etc/ 底下文件名『刚好是五个字母』的文件名
[root@www ~]# ll -d /etc/????? <==由于 ? 表示一定有一个，所以五个 ? 就对了

范例三：找出 /etc/ 底下文件名含有数字的文件名
[root@www ~]# ll -d /etc/*[0-9]* <==记得中括号左右两边均需 *

范例四：找出 /etc/ 底下，档名开头非为小写字母的文件名
[root@www ~]# ll -d /etc/[^a-z]* <==注意中括号左边没有 *

范例五：将范例四找到的档案复制到 /tmp 中
[root@www ~]# cp -a /etc/[^a-z]* /tmp
```

## 5 管线命令

管线命令使用 `|` 符号，管线命令就是对数据进行过滤，从而显示我们想要的数据。

```shell
# 单独使用 ls -al 查看文件列表时会展示所有文件信息，我们需要进行翻页展示就用管线命令
[root@www ~]# ls -al /etc | less
```

每个管线后面接的第一个数据必须是**指令**，例如 less, more, head, tail 等都可以在管线命令后面。

### 5.1 管线命令后使用cut

这个命令可以将一段信息的磨一段切出来，处理信息是以**行**为单位。

语法：

```shell
[root@www ~]# cut -d'分隔字符' -f fields <==用于有特定分隔字符
[root@www ~]# cut -c 字符区间 <==用亍排列整齐的讯息
选项与参数：
-d ：后面接分隔字符。与 -f 一起使用；
-f ：依据 -d 的分隔字符将一段讯息分割成为数段，用 -f 取出第几段的意思；
-c ：以字符 (characters) 癿单位取出固定字符区间；

#################################################################################

范例一：将 PATH 变量取出，我要找出第五个路径。
[root@www ~]# echo $PATH
/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games:
# 1 | 2 | 3 | 4 | 5 | 6 | 7
[root@www ~]# echo $PATH | cut -d ':' -f 5
# 如同上面的数字显示，我们是以『 : 』作为分隔，因此会出现 /usr/local/bin
# 那么如果想要列出第 3 不第 5 呢？，就是这样：
[root@www ~]# echo $PATH | cut -d ':' -f 3,5

范例二：将 export 输出的讯息，取得第 12 字符以后的所有字符串
[root@www ~]# export
declare -x HISTSIZE="1000"
declare -x INPUTRC="/etc/inputrc"
declare -x KDEDIR="/usr"
declare -x LANG="zh_TW.big5"
.....(其他省略).....
# 注意看，每个数据都是排列整齐的输出！如果我们不想要『 declare -x 』时，
# 就得这么做：
[root@www ~]# export | cut -c 12-
HISTSIZE="1000"
INPUTRC="/etc/inputrc"
KDEDIR="/usr"
LANG="zh_TW.big5"
.....(其他省略).....
# 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！
# 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！
```

### 5.2 管线命令后使用grep

cut是取出我们想要的某部分，grep则是分析一行数据，若当中有我们需要的数据，就把改行拿出来。

语法：

```shell
[root@www ~]# grep [-acinv] [--color=auto] '搜寻字符串' filename
选项与参数：
-a ：将 binary 档案以 text 档案的方式搜寻数据
-c ：计算找到 '搜寻字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：过滤选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
--color=auto ：可以将找到的关键词部分加上颜色的显示喔！

#################################################################################

范例一：将 last 当中，有出现 root 的那一行就取出来；
[root@www ~]# last | grep 'root'

范例二：与范例一相反，只要没有 root 的就输出！
[root@www ~]# last | grep -v 'root'

范例三：在 last 的输出讯息中，叧要有 root 就取出，并且仅取第一栏
[root@www ~]# last | grep 'root' |cut -d ' ' -f1
# 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！

范例四：取出 /etc/man.config 内含有 MANPATH 癿那几行
[root@www ~]# grep --color=auto 'MANPATH' /etc/man.config
....(前面省略)....
MANPATH_MAP /usr/X11R6/bin /usr/X11R6/man
MANPATH_MAP /usr/bin/X11 /usr/X11R6/man
MANPATH_MAP /usr/bin/mh /usr/share/man
# 神奇的是，如果加上 --color=auto 的选项，找到的关键词部分会用特殊颜色显示喔！
```

### 5.3 管线后使用排序命令（sort,wc,uniq）

1. sort语法: （排序）

```shell
[root@www ~]# sort [-fbMnrtuk] [file or stdin]
选项与参数：
-f ：忽略大小写癿差异，例如 A 不 a 规为编码相同；
-b ：忽略最前面的空格符部分；
-M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
-n ：使用『纯数字』进行排序(默认是以文字型态来排序的)；
-r ：反向排序；
-u ：就是 uniq ，相同的数据中，仅出现一行代表；
-t ：分隔符，预设是用 [tab] 键来分隔；
-k ：以那个区间 (field) 来进行排序的意思

#################################################################################

范例一：个人账号都记录在 /etc/passwd 下，请将账号进行排序。
[root@www ~]# cat /etc/passwd | sort

范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？
[root@www ~]# cat /etc/passwd | sort -t ':' -k 3
```

2.uniq语法：（去掉重复的值）

```shell
[root@www ~]# uniq [-ic]
选项与参数：
-i ：忽略大小写字符的不同；
-c ：进行计数

#################################################################################

范例一：使用 last 将账号列出，仅取出账号栏，进行排序后仅取出一位；
[root@www ~]# last | cut -d ' ' -f1 | sort | uniq

范例二：承上题，如果我还想要知道每个人的登入总次数呢？
[root@www ~]# last | cut -d ' ' -f1 | sort | uniq -c
```

3.wc语法：（显示档案的字数、行数、字符数）

```shell
[root@www ~]# wc [-lwm]
选项与参数：
-l ：仅列出行；
-w ：仅列出多少字(英文单字)；
-m ：多少字符；

#################################################################################

范例一：那个 /etc/man.config 里面刡底有多少相关字、行、字符数？
[root@www ~]# cat /etc/man.config | wc
141 722 4617
# 输出的三个数字中，分别代表： 『行、字数、字符数』
```



