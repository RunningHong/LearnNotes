[toc]

# HBase Rowkey设计原则

## 1 目标

结合业务特点，将数据合理的分配到每一个Region中，从而很好的满足业务的读写需求；

1-查询条件字段的离散度信息？字段离散度的定义:字段A的离散度=（字段A的可能的枚举值数据）/数据总记录条数

2-查询条件字段的数据分布特点？--数据分布影响RowKey的设计，更进一步影响如何查询合理的划分Region信息

3-数据生命周期--影响到一个表的一次Major Compaction发生时涉及到的最大数据量

## 2 热点问题

HBase中的行是按照rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan。然而糟糕的rowkey设计是热点的源头。 热点发生在大量的client直接访问集群的一个或极少数个节点（访问可能是读，写或者其他操作）。大量访问会使热点region所在的单个机器超出自身承受能力，引起性能下降甚至region不可用，这也会影响同一个RegionServer上的其他region，由于主机无法服务其他region的请求。 设计良好的数据访问模式以使集群被充分，均衡的利用。

## 3 RowKey的设计

### **遵循的最基本原则**：

- **唯一性**：RowKey必须能够唯一的识别一行数据；无论应用时什么样的负载特点，RowKey字段都应该参考最高频的查询场景。数据库通常都是以如何高效的读取和消费数据为目的，而不是存储本身。而后，结合具体的负载特点，再对选取的RowKey字段值进行改造，组合字段场景下需要重点考虑字段的顺序。
- **长度要短**：RowKey是一个二进制码流，可以是任意字符串，最大长度 64kb ，实际应用中一般为10-100bytes，以 byte[] 形式保存，一般设计成定长。建议越短越好，不要超过16个字节，原因如下：
    1. 数据的持久化文件HFile中是按照KeyValue存储的，如果rowkey过长，比如超过100字节，1000w行数据，光rowkey就要占用100*1000w=10亿个字节，将近1G数据，这样会极大影响HFile的存储效率；
    2. MemStore将缓存部分数据到内存，如果rowkey字段过长，内存的有效利用率就会降低，系统不能缓存更多的数据，这样会降低检索效率。

### 避免数据热点的方法-Reversing

- 如果经过初步涉及出的RowKey在数分布不均匀，但是RowKey尾部的数据却呈现了良好的随机性。此时，可以考虑将RowKey的信息反转，或者直接将我i不的bytes提前到RowKey的前部。
- 缺点：场景利于Get但不利于Scan，因为数据在原RowKey上的自然顺序已经被打乱。

### 避免数据热点的方法--Salting

- Salting的原理是在原RowKey的前面添加固定长度的随机bytes，随机bytes能保障数据在所有Regions间的负载均衡。
- 缺点：既然是随机bytes，基于原RowKey查询时无法获知随机bytes信息是什么，也就是需要去各个可能的Regions中去查看。可见，Salting对于读取是利空的。

### 避免数据热点的方法-Hashing

- 
- 基于RowKey的完整或部分数据进行Hash，而后将Hashing后的值完整替换原RowKey或者部分替换RowKey的前缀部分；
- 缺点：与reversing类似，Hashing也不利于Scan，因为打乱了原RowKey的自然顺序。

## ps-相关资料

[HBase-Rowkey设计原则](https://www.jianshu.com/p/fefcad20feb7)

[HBase RowKey设计原则](https://www.jianshu.com/p/83ae227902d5)