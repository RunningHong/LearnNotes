[TOC]

# 多线程实现方式

## 1 继承Thread类

### 1.1 代码实现

这里继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.

```java
package com.hong.concurrent;

/**
 * @author hongzh.zhang on 2021/01/17
 *
 */
public class ThreadTest extends Thread {
    public static void main(String[] args) {
        Thread thread1 = new ThreadTest("A");
        Thread thread2 = new ThreadTest("B");

        thread1.start();
        thread2.start();
    }

    private String name;

    public ThreadTest(String name) {
        this.name = name;
    }

    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(name + "运行  :java  " + i);
            try {
                sleep((int) Math.random() * 10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

运行结果：

```java
A运行  :  0
B运行  :  0
A运行  :  1
B运行  :  1
A运行  :  2
B运行  :  2
A运行  :  3
A运行  :  4
B运行  :  3
B运行  :  4
```

程序启动运行main时候，java虚拟机启动一个进程，主线程在main()调用时候被创建。随着调用thread1的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。

start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。

从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。

Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。

实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。

### 1.2 Thread中常用方法

| 名称    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| start   | 启动当前线程，调用线程的run()                                |
| run     | 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中。 |
| sleep   | 线程睡眠，Thread.sleep(毫秒)                                 |
| yield   | 线程礼让，释放当前cpu的执行权（下次还可以争抢）              |
| join    | 在线程a中调用线程b的join(),此时线程a进入阻塞状态，直到线程b完全执行完以后线程a才结束阻塞状态。 |
| getName | 获取线程名称                                                 |
| setName | 设置线程名称                                                 |

## 2 实现Runnable接口

### 2.1 代码实现

```java
public class ImplsRunnable implements Runnable {

	Logger log = LoggerFactory.getLogger(ImplsRunnable.class);

	public static void main(String[] args) {
		Thread thread1 = new Thread(new ImplsRunnable("C"));
		Thread thread2 = new Thread(new ImplsRunnable("D"));

		thread1.start();
		thread2.start();
	}

	private String name;

	public ImplsRunnable(String name) {
		this.name = name;
	}


	@Override
	public void run() {
		for (int i = 0; i < 5; i++) {
			System.out.println(name + "运行  :  " + i);
			try {
				Thread.sleep((int) Math.random() * 10);
			} catch (InterruptedException e) {
				log.error("错误", e.getMessage());
			}
		}
	}
}
```

### 2.2 实现Runnable接口的优势

实现Runnable接口比继承Thread类所具有的优势：

1. 适合多个相同的程序代码的线程去处理同一个资源
2. 可以避免java中的单继承的限制
3. 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
4. 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类

## 3 











