[TOC]

# 多线程实现方式

## 1 继承Thread类

### 1.1 代码实现

这里继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.

```java
package com.hong.concurrent;

/**
 * @author create by hongzh.zhang on 2021-01-27
 * 多线程初试
 * 使用继承Thread类的形式实现多线程
 * 各自打印0到4
 */
public class T01ThreadTest extends Thread {

    private String name;

    public T01ThreadTest(String name) {
        this.name = name;
    }

    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(name + "运行  :java  " + i);
            try {
                sleep((int) Math.random() * 10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        Thread thread1 = new T01ThreadTest("A");
        Thread thread2 = new T01ThreadTest("B");

        thread1.start();
        thread2.start();
    }

}
```

运行结果：

```java
B运行  :java  0
A运行  :java  0
B运行  :java  1
B运行  :java  2
B运行  :java  3
B运行  :java  4
A运行  :java  1
A运行  :java  2
A运行  :java  3
A运行  :java  4
```

程序启动运行main时候，java虚拟机启动一个进程，主线程在main()调用时候被创建。随着调用thread1的两个对象的start方法，另外两个线程也启动了，这样整个应用就在多线程下运行。

start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。

从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。

Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。

实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。

### 1.2 Thread中常用方法

| 名称    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| start   | 启动当前线程，调用线程的run()                                |
| run     | 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中。 |
| sleep   | 线程睡眠，Thread.sleep(毫秒)                                 |
| yield   | 线程礼让，释放当前cpu的执行权（下次还可以争抢）              |
| join    | 在线程a中调用线程b的join(),此时线程a进入阻塞状态，直到线程b完全执行完以后线程a才结束阻塞状态。 |
| getName | 获取线程名称                                                 |
| setName | 设置线程名称                                                 |

## 2 实现Runnable接口

### 2.1 代码实现

```java
package com.hong.concurrent;

import static java.lang.Thread.sleep;

/**
 * @author create by hongzh.zhang on 2021-01-27
 * 多线程初试
 * 使用实现Runnable接口的形式实现多线程
 * 各自打印0到4
 */
public class T02RunnableTest implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println( Thread.currentThread().getName() + "运行  :java  " + i);
            try {
                sleep((int) Math.random() * 10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new T02RunnableTest());
        thread1.setName("A");
        Thread thread2 = new Thread(new T02RunnableTest());
        thread2.setName("B");
        thread1.start();
        thread2.start();
    }
}

```

### 2.2 实现Runnable接口的优势

实现Runnable接口比继承Thread类所具有的优势：

1. 适合多个相同的程序代码的线程去处理同一个资源
2. 可以避免java中的单继承的限制
3. 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类

## 3 实现Callable接口















