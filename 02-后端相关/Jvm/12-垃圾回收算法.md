[toc]

# 垃圾回收算法

## 1 标记阶段

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为**垃圾标记阶段**。 

 判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法。** 

### 1.1 引用计数法（Java未使用该算法）

#### 1.1.1 概念

引用计数算法（Reference Counting）：对每个对象保存一个整型的**引用计数器属性**，用于记录对象被引用的情况。 

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。 

#### 1.1.2 优缺点

- 优点
    1.  实现简单，垃圾对象便于辨识；
    2.  判定效率高，回收没有延迟性。 
- 缺点
    1.  它需要单独的字段存储计数器，这样的做法增加了存储空间的开销；
    2.  每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。；
    3.  **无法处理循环引用**的情况 , 这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。 
        循环引用举例：
        当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏 
        <img src="picture/1609564952782.png" alt="1609564952782" style="zoom:57%;" />

#### 1.1.3 Python中的引用计数算法

引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。 

python中如何解决循环引用这个问题：

1.  手动解除：很好理解，就是在合适的时机，解除引用关系。  
2.  使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。 

### 1.2 可达性分析算法（根搜索算法、追踪性垃圾收集）

#### 1.2.1 概念

可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集。

**基本思路**：通过一系列称为“**GC Roots**”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为**引用链**（Reference Chain），当一个对象到GC Roots没有任何引用链相连（**用图论的话来说就是从GC Roots到这个对象不可达**）时，则证明此对象引用不可用，此时就会被判定为可回收对象。

相对于引用计数算法而言，可达性分析算法可以有效地解决循环引用的问题，防止内存泄漏的发生。

<img src="picture/1609565436248.png" alt="1609565436248" style="zoom:57%;" />

#### 1.2.2 GC Roots包括哪些

1. 虚拟机栈中引用的对象
    - 比如：各个线程被调用的方法中使用到的参数、局部变量等。
2. 本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象
    - 比如：Java类的引用类型静态变量
3. 方法区中静态属性引用的对象
4. 所有被同步锁synchronized持有的对象
5. Java虚拟机内部的引用。
    - 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointException、OutOfMemoryError），系统类加载器。
6. 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

## 2 对象的finalization机制

即使在可达性分析算法中不可达的对象，也并非是非死不可的，要真正宣告一个对象死亡，至少要经历**两次标记**过程：**如果对象在进行可达性分析后发现没有GC Roots相链接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法**。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行操作。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()方法中成功解救自己，只需要重新与引用链上的任何一个对象建立关联即可，这样在第二次标记时它将被溢出“即将收回”的集合；如果对象这个时候还没有逃脱，那基本上它就真的被回收了。

**任何一个对象的finalize()方法都只会被系统自动调用一次**，如果执行了一次，那么下一次对象面临回收时，它的finalize()方法将不会执行。finalize()方法并不被提倡使用，它的运行代价很高，不确定大，无法保证各个对象的调用顺序。





## 3 清除阶段

### 3.1 标记-清除算法



### 3.2 复制算法



### 3.3 标记-整理算法







## ps-相关资料

[垃圾回收算法](https://gitee.com/moxi159753/LearningNotes/tree/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95)