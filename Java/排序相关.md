---
typora-root-url: ..\picture
---

# 1 排序相关

![算法时间复杂度稳定性综合](/算法时间复杂度稳定性综合.png)

**稳定性**：通俗地讲就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。

## 1.1 冒泡排序

```java
    /**
     * 冒泡排序算法（从小到大）
     * 说明：依次比较两个相邻的数，如果第一个个数比第二个数大则交换这连个数的位置
     * @param array
     * @return
     */
    public int[] bubbleSort(int[] array) {
        for(int i=0; i<array.length; i++) {
            for(int j=i+1; j<array.length; j++) {
                if(array[i] > array[j]) {
                    // 利用异或操作交换两个数字（好处：不引入新的变量，没有溢出问题产生）
                    array[i] = array[i] ^ array[j];
                    array[j] = array[i] ^ array[j];
                    array[i] = array[i] ^ array[j];
                }
            }
        }
        return array;
    }
```

冒泡排序是最简单的排序算法，时间复杂度为O(n<sup>2</sup>)；

算法思路：依次比较相邻的两个数，如果按照判断条件则进行相应的交换两个数字的操作。因为每次都是把一个数放到最前或最后，很像泡泡从水底冒出的样子，故命名为冒泡算法。

如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个元素相邻起来，最终也不会交换它俩的位置，所以相同元素经过排序后顺序并没有改变。所以冒泡排序是一种稳定排序算法。 

## 1.2 选择排序

```java
    /**
     * 选择排序算法
     * 说明：选择排序的工作原理是每一次从待排序的序列中选择最小（或最大的元素）放在序列的初始位置
     * @param array
     * @return
     */
    public int[] selectionSort(int[] array) {
        int minIndex = 0;
        int temp;
        for(int i=0; i<array.length; i++) {
            minIndex = i; // 初始设置最小的值下标为i
            for(int j=i+1; j<array.length; j++) {
                if(array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            // 每一次循环，找到最小的值的下标后，交换两个数的位置
            temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
        return array;
    }
```

时间复杂度为O(n<sup>2</sup>)；

算法**不稳定**; 举个例子：序列5 8 5 2 9， 我们知道第一趟选择第1个元素5会与2进行交换，那么原序列中两个5的相对先后顺序也就被破坏了。所以选择排序是一个**不稳定**的排序算法。          

## 1.3 插入排序

插入排序有可以分为**直接插入排序**和**希尔排序**。

### 1.3.1 直接插入排序

```java

```

![img](/selectionSort.png)



###1.3.2 希尔排序









	





















