[TOC]

# 面试知识点笔记

## 1 右移和无符号右移

x=5,5的二进制是0101。

x=5>>2 （>>带符号右移）

将0101右移2位，为：0001。

y=x>>>2 （>>>无符号右移，左边空缺补充为0）

将0001右移2位，补0。结果为：0000

## 2 Java数字类型相关

Java中整型默认的为int，浮点默认的为double。

float f = 1.1 为错，1.1为double类型，大转小，double不能转为float

int i = 0.0 为错，0.0为double类型,大转小，double不能转为int

Double ddd = 3为错，int无法直接转换为Double

## 3 DBMS特性（持一原隔）

DBMS中有四个特性 ：**持久性**、**一致性**、**原子性**、**隔离性**。

持久性：数据库的恢复，实现恢复管理子系统；

一致性：数据库的并发控制；

原子性：数据库的完整性控制；

隔离性：数据库的安全控制。

## 4 Java类加载器

**启动类加载器（bootstrap class loader）**：用来加载Java的核心库，用原生代码实现。

**扩展类加载器（extensions class loader）**:加载Java的扩展库。

**应用程序加载器/系统类加载器（system class loader）**:它根据Java应用的类路径（classpath)来加载类。

说到类加载器那么就要谈谈类加载器之间的关系，加载器之间的关系称作为**双亲委派模型**（除了bootstrap ClassLoader外，其他的类加载器都有自己的父类加载器，类加载器都是使用组合关系来复用父类加载器的代码）

**双亲委派模型**工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器都是这样的，因此所有的加载器请求最终都应该传送到顶层的启动类加载器，之后当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

## 5 实例变量、实例方法、静态变量（类变量）、静态方法（类方法）

**实例成员**包括**实例变量**和**实例方法**，也就是平时说的成员变量和成员方法。

**类成员（静态成员）**包括**静态变量**和**静态方法** ，静态变量也叫做类变量，静态方法也叫做类方法。

在静态方法（类方法）中没有this指针，即不能通过this来调用本类的类方法。

静态变量只能在类主体中定义不能在方法中定义。

## 6 volatile关键字的功能

 **保证可见性** ：

可见性指的是在一个线程中对该变量的修改会马上由**工作内存**（Work   Memory）写回**主内存**（Main   Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，**工作内存是线程独享的，主存是线程共享的**。 

 **禁止指令重排序优化** ：

禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。

## 7 final知识点

1、final关键字可以用于成员变量、本地变量、方法以及类。

2、 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。

3、 不能够对final变量再次赋值。

4、 本地变量必须在声明时赋值。

5、 在匿名类中所有变量都必须是final变量。

6、 final方法不能被重写。

7、 final类不能被继承。

8、 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。

## 8 Java表达式转型规则

Java表达式转型规则**由低到高转换**： 

  1、所有的byte,short,char型的值将被提升为int型； 

  2、如果有一个操作数是long型，计算结果是long型； 

  3、如果有一个操作数是float型，计算结果是float型； 

  4、如果有一个操作数是double型，计算结果是double型； 

   5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

例如：

```java
byte b1=1,b2=2;
final byte b4=4,b5=5;
byte b3 = b1 + b2; // 错误，b1+b2被转换为int进行计算，算出的结果					  // 为int类型，不能直接赋值给byte类型
byte b6 = b4 + b5; // 正确，final使变量不会自动提升类型（见上）
```

## 9 Java数组复制效率比较

**效率：System.arraycopy() > clone ()> System.copyOf() > for循环** 

## 10 import注意

import java.util.*只能读取java/util目录下的类，不能读取其子目录的类。因为如果java.util里面有个a类，java.util.regex里面也有个A类，我们若是要调用A类的方法或属性时，就不知道调用那个类了。 

## 11 类初始化过程

1.首先，初始化**父类中的静态成员变量和静态代码块**，按照在程序中出现的顺序初始化； 

2.然后，初始化**子类中的静态成员变量和静态代码块**，按照在程序中出现的顺序初始化； 

3.其次，初始化**父类的普通成员变量和代码块**，再执行**父类的构造方法**；

4.最后，初始化**子类的普通成员变量和代码块**，再执行**子类的构造方法**；

## 12 Byte类型值

 Byte类型值大小为-128~127之间 

如果Byte b = 127；b++；则b==-128；

## 13 null相关

null可以被强制类型转换成任意类型（不是任意类型对象） 

比如：`((A)null).testMethod();`把null转换为A类型，之后调用A的静态方法。

null不属于java.lang.Object类型。

## 14  异常处理相关

程序运行时异常有Java虚拟机自动进行处理

捕获到的异常可以**将异常抛给调用它的上一级方法来处理** 。

## 15 HttpServlet容器响应Web客户请求流程  

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

## 16 ThreadLocal类

1、ThreadLocal的类声明：public class ThreadLocal<T>

可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。

2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立。

3、由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中。

## 17 HashMap、HashTable、Vector、IndetityHashMap继承以及接口

```java
public class Hashtable<K,V> extends Dictionary<K,V>

		implements Map<K,V>, Cloneable, java.io.Serializable

 
public class HashMap<K,V>  extends AbstractMap<K,V>

		implements Map<K,V>, Cloneable, Serializable


public class Vector<E> extends AbstractList<E>

		implements List<E>, RandomAccess, Cloneable, java.io.Serializable


public class IdentityHashMap<K,V> extends AbstractMap<K,V>

		implements Map<K,V>, java.io.Serializable, Cloneable
```

## 18 访问权限控制 

**public>protected>默认(包访问权限)>private** 

![img](https://uploadfiles.nowcoder.com/images/20180815/6855549_1534319281240_994B36FBA5D0176311889BFCC3F57C1F) 

## 19 Java四类八种基本数据类型

第一类：整数类型  byte short int long

第二类：浮点型  float double

第三类：逻辑型  boolean(它只有两个值可取true false)

第四类：字符型  char

## 20 interface变量、方法声明相关

接口中默认修饰变量属性用：public static final；

默认方法的修饰符是：public abstract 

## 21 try{ }、catch{ }、finally{ }返回值的问题

 try{ }中返回了某一个值，如果finally也有return，则finally中的返回值会覆盖try的返回值；如果finally没有返回值，则return try｛｝中缓存的返回值。

## 22 通信的三要素

由**信源**（发端设备）、**信宿**（收端设备）和**信道**（传输媒介）等组成，被称为通信的三要素。

## 23 PPP协议

PPP协议是一种点——**点串行通信协议**。

PPP具有处理错误检测、支持多个协议、允许在连接时刻协商IP地址、允许身份认证等功能，还有其他。PPP提供了3类功能：成帧；链路控制协议LCP；网络控制协议NCP。

PPP是面向**字符类型**的协议。  而HDLC是面向比特的（位）

## 24 网络拓扑结构

物理拓扑结构是星型，逻辑拓扑结构是总线型。

10base是物理上星型结构，逻辑总线型；

100base是逻辑物理都是星型结构。

## 25 String的intern()方法

如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表常量池中这个字符串的String对象；否则创建新String对象并把改字符串添加到常量池，并返回此String对象的引用。

## 26 物理层的特性

- 机械特性——描述接头的形状和尺寸，引线数目和排列；
- 功能特性——接口部件的信号线（数据线、控制线、定时线等）的用途 
- 规程特性——接口部件的信号线在建立、维持、释放物理连接和传输比特流的时序。
- 电气特性——指明什么样的电信号表示0和1；

## 27 数据链路两端的设备

DTE或DCE。

Data Terminal Equipment（DTE），数据终端设备，指具有一定的数据处理能力和数据收发能力的设备。

DCE Data Communications Equipment（数据通信设备）的首字母缩略词，它在DTE和传输线路之间提供信号变换和编码功能，并负责建立、保持和释放链路的连接。

## 28 网络中的各种协议

**FTP**（文件传输协议、File Transfer Protocol）是用于文件传输的Internet标准。FTP支持一些文本文件（例如ASCII、二进制等等）和面向字节流的文件结构。FTP**使用传输层协议TCP**在支持FTP的终端系统间执行文件传输，因此，FTP被认为提供了可靠的面向连接的服务，适合于远距离、可靠性较差线路上的文件传输。

**TFTP**（Trivial File Transfer Protocol，简单文件传输协议）也是用于文件传输，但TFTP**使用UDP**提供服务，被认为是不可靠的，无连接的。TFTP通常用于可靠的局域网内部的文件传输。

**SMTP**（Simple Mail Transfer Protocol。简单邮件传输协议）支持文本**邮件**的Internet传输。

POP3（Post Office Protocol）是一个流行的Internet邮件标准。

SNMP（Simple Network Management Protocol。简单网络管理协议）负责网络设备监控和维护，支持安全管理、性能管理等。

Telnet是客户机使用的与远端服务器建立连接的标准终端仿真协议。

Ping命令是一个诊断网络设备是否正确连接的有效工具。

Tracert命令和Ping命令类似，可以显示数据包经过的每一台网络设备信息，是一个很好的诊断命令。

HTTP协议支持WWW（World Wide Web，万维网）和内部网信息交互，支持包括视频在内的多种文件类型。HTTP是当今流行的Internet标准。

DNS（Domain Name System，域名系统）把网络节点的易于记忆的名字转化为网络地址。

WINS（Windows Internet Name Server，Windows Internet命名服务器），此服务可以将NetBIOS 名称注册并解析为网络上使用的IP地址。

BootP（Bootstrap Protocol，引导协议）是使用传输层UDP协议动态获得IP地址的协议。

## 29 各个层的数据单元

- 应用层：数据
- 传输层：数据段
- 网络层：数据包
- 网络接口层：帧

## 30 ARP协议(地址解析协议)

- ARP:IP地址到物理地址
- DNS:域名到IP地址

## 31 缺省子网掩码

- A类地址：255.0.0.0
- B类地址：255.255.0.0
- C类地址：255.255.255.0

## 32 子类构造器，父类构造器之间的问题

在调用子类构造器之前，会先调用父类构造器。

当子类构造器中**没有使用"super**(参数或无参数)"指定调用父类构造器时，是**默认调用父类的无参构造器**，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。

## 33 Spring依赖注入的三种方式

- 接口注入
- setter方法注入
- 构造方法注入

## 34 Thread.sleep()抛出的异常

将会抛出InterruptedException异常。

## 35 Thread中join()方法的作用

join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。

## 36 静态内部类和非静态内部类的区别

1. 静态内部类可以不依赖与外部类实例被实例化，非静态内部类需要在外部类被实例化后才能被实例化。
2. 内部类不能直接访问外部类的成员，除非是静态内部类访问外部类的静态成员。
3. 静态内部类可以有静态成员，非静态内部类不能有静态成员。
4. 非静态内部类的非静态成员可以访问外部类的非静态变量。

## 37 JVM判断两个类是否相同

- 类的全称
- 类加载器

类全称和类加载器一起来判断两个类是否相同。

## 38 Interface是否继承Object类

首先interface不会有继承，interface只有实现没有继承，其实Interface是实现了一个Object接口。

## 39 依赖注入&控制反转

依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。

**依赖注入**是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；

**控制反转**是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。

## 40 是否可以释放掉一个指定占据的内存空间

不可以，在Java虚拟机中明确的指出，释放占据的内存室友GC完成的，程序员无法明确强制其运行，而且释不释放取决于GC，无法由程序员通过代码控制，调用System.gc(),不会马上机型垃圾回收。

## 41 JSP内置对象

1、pageContext 表示页容器 EL表达式、 标签 、上传 
2、request 服务器端取得客户端的信息：头信息 、Cookie 、请求参数 
3、response 服务器端回应客户端信息：Cookie、重定向 
4、session 表示每一个用户，用于登录验证上 
5、application 表示整个服务器 
6、config 取得初始化参数，初始化参数在web.xml文件中配置 
7、exception 表示的是错误页的处理操作 
8、page 如同this一样，代表整个jsp页面自身 
9、out 输出 ，但是尽量使用表达式输出

## 42 Java Unicode相关

Java默认的字符集是Unicode（占两个字节byte，一个字节==8个比特位，所以Unicode占用16位）

## 43 抛InterruptedException的代表方法

- java.lang.Object 类的 wait 方法
- java.lang.Thread 类的 sleep 方法
- java.lang.Thread 类的 join 方法

## 44 字节流、字符流

字节流继承于InputStream、OutputStream

字符流继承于InputStreamReader、OutputStreamWriter

**字节流**：

InputStream

|-- FileInputStream (基本文件流）

|-- BufferedInputStream

|-- DataInputStream

|-- ObjectInputStream

**字符流**：

Reader 
|-- InputStreamReader (byte->char 桥梁） 
|-- BufferedReader (常用） 
Writer 
|-- OutputStreamWriter (char->byte 桥梁） 
|-- BufferedWriter 
|-- PrintWriter （常用）

## 45 LinkedBlockingQueue相关

**LinkedBlockingQueue**：基于链接节点的可选限定的blocking queue 。 这个队列排列元素FIFO（先进先出）。 队列的头部是队列中最长的元素。 队列的尾部是队列中最短时间的元素。 新元素插入队列的尾部，队列检索操作获取队列头部的元素。 链接队列通常具有比基于阵列的队列更高的吞吐量，但在大多数并发应用程序中的可预测性能较低。

**blocking queue说明**：不接受null元素；可能是容量有限的；实现被设计为主要用于生产者 - 消费者队列；不支持任何类型的“关闭”或“关闭”操作，表示不再添加项目实现是线程安全的；

## 46 常用ASCII码

‘0’对应48、‘A’对应68、‘a’对应97、空格对应160

## 47 事务属性的种类

包括**传播行为、隔离级别、只读和事务超时**。

1. **传播行为**：定义了被调用方法的事务边界。
2. **隔离级别**：在操作数据时可能带来3个副作用，分别是**脏读**、**不可重复读**、**幻读**。为了避免这三个副作用的发生，在标准的SQL语句中定义了4种隔离级别，分别是**未提交读**、**已提交读**、**可重复读**、**可序列化**。
3. **只读**：只读代表着所有的操作只读取数据库中的数据，而并不是更新数据。
4. **事务超时**：如果一个事务长时间运行，这是为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。

## 48 wait和notify

wait方法使线程进入等待锁定池，只有针对此对象发出notify方法获得对象锁进入就绪状态。

## 49 假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为

答案：this(x)，注意不是this.A(x),也不是A(X)

## 50 Java用()机制实现了进程之间的同步执行

答案：监视器。

在jvm中是使用**监视器锁**来实现不同线程的异步执行，在语法的表现就是**synchronized**  。

## 51 能不能自己写个类叫`java.lang.System`？

答案：通常是不可以的，但也可以达到这个做法。

解释：为了不让我们写System类，类加载采用**双亲委托机制**。System类是Bootstrap classloader加载的，就算是重写，也总是使用Java系统提供的System,所以自己写的System类无法得到加载。

但是，我们也可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。

## 52 JVM打破双亲委托机制

双亲委托机制是JVM中的规范。

如果想打破双亲委托机制只需要实现自己的classloader，这样按照什么样加载都是由自己决定的了。

重写loadClass方法，将需要特殊对待的类自己先处理，非处理范围的类调用super方法即可。

## 53 避免死锁的一个著名的算法

银行家算法。

## 54 什么类不能被继承？

1、如果类被final修饰，那么此类不可以被继承。

2、如果类中只有private的构造方法，那么此类不可以被继承。

 其原因在于：

 （1）一个类一定会有构造函数，如果不写，那就是默认的无参构造函数，如果写，就只有所写的构造函数。

 （2）子类的构造函数一定会调用父类的构造函数，但是如果父类中只有私有的构造方法，那么子类就无法调用父类，就会有问题。

## 55 什么是存储过程

存储过程是一些预编译的SQL语句。

自我理解：存储过程就是一个记录集，这个记录集就像方法一样，有一些列过程（sql语句），存储过程可以像方法一样被调用。

- 存储过程是一个预编译的代码块，执行效率比较高
- 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
- 可以一定程度上确保数据安全

## 56 数据库的乐观锁和悲观锁是什么？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

## 57 使用索引查询一定能提高查询的性能吗？为什么

通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.

索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能。

索引范围查询(INDEX RANGE SCAN)适用于两种情况:

- 基于一个范围的检索,一般查询返回结果集小于表中记录数的30%
- 基于非唯一性索引的检索

## 58 简单说一说**drop、delete**与**truncate**的区别

- **delete和truncate**只删除表的数据不删除表的结构
- 速度,一般来说: **drop> truncate >delete** 
- **delete**语句是dml,这个操作会放到**rollback segement**中,事务提交之后才生效;如果有相应的**trigger**,执行的时候将被触发.
- **truncate,drop**是ddl, 操作立即生效,原数据不放到r**ollback segment**中,不能回滚. 操作不触发**trigger**. 

## 59 **drop、delete**与**truncate**分别在什么场景之下使用？

- 不再需要一张表的时候，用**drop**
- 想删除部分数据行时候，用**delete**，并且带上where子句
- 保留表而删除所有数据的时候用**truncate**

## 60 什么是视图？以及视图的使用场景有哪些？

视图是一种**虚拟的表**，**具有和物理表相同的功能**。可以对视图进行增，改，查操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

- 只暴露部分字段给访问者，所以就建一个虚表，就是视图。
- 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

## 61 运行时异常与受检异常有何异同？

异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：

- 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
- 优先使用标准的异常
- 每个方法抛出的异常都要有文档
- 保持异常的原子性
- 不要在catch中忽略掉捕获到的异常

## 62 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?

sleep()方法（休眠）是**线程类（Thread）的静态方法**，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是**对象的锁依然保持**，因此休眠时间结束后会自动恢复。

wait()是**Object类的方法**，调用对象的wait()方法导致**当前线程放弃对象的锁**（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

> **补充：**可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。

## 63 线程的sleep()方法和yield()方法有什么区别？

① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

## 64 什么是线程池（thread pool）？

答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。
Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：

- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。
- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。

## 65 线程状态转换图（运行、阻塞、等待）

![img](https://camo.githubusercontent.com/a1015109970ac4045badd0c132ef97e191da8186/68747470733a2f2f75706c6f616466696c65732e6e6f77636f6465722e636f6d2f696d616765732f32303138303730312f333830373433355f313533303432343634363830315f3336353841383733333532443144354642394546373444394639463146304235)

## 66 在进行数据库编程时，连接池有什么作用？

答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。

## 67 获得一个类的类对象有哪些方式？

1. 类型.class，例如：String.class
2. 对象.getClass()，例如：”hello”.getClass()
3. Class.forName()，例如：Class.forName(“java.lang.String”)

## 68 如何通过反射创建对象

- 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()
- 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);

## 69 TCP协议如何来保证传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

　　**对于可靠性，TCP通过以下方式进行保证：**

- 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
- 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
- 丢弃重复数据：对于重复数据，能够丢弃重复数据；
- 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。









